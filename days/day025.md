```
package com.company.java011_ex;
// 패키지 다를시 import필요

import java.util.Arrays;

//Apple [name=RED, order=iron, num=2, price=1000]
//Apple [name=GREEN, order=hulk, num=1, price=1500]
//Apple [name=GOLD, order=captain, num=3, price=2000]

public class ClassArrEx1{
	  public static void main(String[] args) {
	        Apple[] apples= new Apple[3]; 
	       
	        //위의 화면처럼 값 셋팅
	        String []name = {"RED","GREEN","GOLD"};
	        String []order = {"iron","hulk","captain"};
	        int []num = {2,1,3};
	        int []price = {1000,1500,2000};
	        
	        
	        apples[0] = new Apple("RED", "iron", 2, 1000);
	        apples[1] = new Apple("GREEN", "hulk", 1, 1500);
	        apples[2] = new Apple("GOLD", "iron", 3, 2000);
	        
	        System.out.println("ver-1 for");
	        for(int i = 0; i<apples.length; i++) {System.out.println(apples[i]);}
	        
	        System.out.println("\nver-2 향상된 for");
	        // 	한개씩 		: 배열, 객체명 
	        for ( Apple a : apples) {System.out.println(a);}
	        
	        Apple[] apples2 = new Apple[] {
	        		new Apple("RED", "iron", 2, 1000) , new Apple("GREEN", "hulk", 1, 1500)
	        		, new Apple("GOLD", "captain", 3, 2000)
	        };
	        System.out.println(Arrays.deepToString(apples2));
	        
	        
//	        for (int i = 0; i < apples.length; i++ ) {
//	        	apples[i] = new Apple(setName[i],setOrder,setNum,setPrice); 
//	        	
//	        	
//	        	apples[i].setName(name[i]);
//	        	apples[i].setNum(num[i]);
//	        	apples[i].setPrice(price[i]);
//	           
//	        }
//	        
//	        System.out.println(apple);
	        
	        
	        //위의 화면처럼 출력
	  }
	}
```

```

package com.company.java011;

//1. 상속? 클래스의 재사용
/* 실선(확장-연결)-속이 빈 화살표(일반화)
   Object		3)			  {			Object		}	  4)
     ↑
     A	int a =10   2)			  {a	 A()		a=10} 5)
     ↑
     B	int b=20   1) new : 1번지 {b   → B()			b=20} 6)
     
     -------------------------------------------------------
     B b1 = new B(); b1.show();
     -------------------------------------------------------
     
     1) extends 상속
     2) is a : A는 Object이다, B도 Object
     3) 생성자호출 : B() → A() → Object
     4) 객체생성  : Object → A → B
     
     
 */
class A extends Object{
	int a=10;
	public A() { super(); }	
}
class B extends A	  {
	int b=20;
	public B() { super(); }
	public void show() {System.out.println(super.a+ " \t" + this.b);}
}

public class Extends001 {
	public static void main(String[] args) {
		B b1 = new B(); b1.show();
	}

}



```

```

package com.company.java011;

import java.util.Arrays;

public class ClassArr001 {
	public static void main(String[] args) {
		// 1) Toy [] 나주소 받을수 있어~
		Toy [] toys = new Toy[3];	//2) new 번지, Toy형태의 자료형 3개		
		System.out.println("1, " + toys);
		System.out.println("2, " + Arrays.toString(toys));
		
		
		toys[0] = new Toy();
		toys[0].setName("할로윈키티"); toys[0].setAge(52);
		System.out.println("3. " + toys[0] );
		
		
		// 사용방법2
		Toy [] toys2 = new Toy[] {
				new Toy("할로윈키티", 52) , new Toy("건담", 47)
		};
		// toys[0].name, toys[0].age
		// toys[1].name, toys[1].age
		
		for (int i=0; i<toys2.length; i++) { toys[i].show();}
		
		/// 클래스명의 뒷쪽에 [] 두번째 부분엔 숫자(층칸수) 선언
		///사용할땐 지역변수명[숫자]
	}
}





/*
------------------------[ runtime data area]
> Toy.class	Class_Repeat.class, Toy.company="(주) 703toyland" , Toy.num=0
------------------------------------
[heap: 동적]            | [stack : 잠깐빌리기]
1번지 [null][null][null]	<- toys [1번지]
						| 	main
		------------------------------------
*/

```






● 6. 클래스다이어그램
1. 시스템을 구성하는 클래스들 사이관계를 표현
2. 클래스 - 객체를 생성하는 설계도
3. staruml.io - 다운로드 - 설치
4. 클래스
----------------------------------------
[Animal]
----------------------------------------
add - attribute (멤버변수)
----------------------------------------
add - operation (멤버함수)
----------------------------------------

5. uml 관계
> 1) 연관관계 ( 연결 → 한쪽은 알지만, 다른쪽은 상대방의 존재는 모름 )
> 2) 일반화관계(상속, IS-A 고양이는 동물이다, 속이 빈 화살표   )
      고양이는 동물이다(O), 사람도 동물이다(O), 동물은 고양이다? (X)
> 3) 집합관계 (자동차 = 엔진 + 휠 
                ◆ 생성자안에서 new (합성)   ,   ◇ 생성자 안에서 주소(집약) )
4) 의존관계
5) 실체화관계(인터페이스)

6. SOLID 원칙 
S : 단일책임      - 한클래스는 한가지 일만해요.  (쿠키굽기)
O : 개방폐쇄      - 새로운 쿠키는 쉽게 추가 (확장가능, 수정닫힘)
L : 리스코프치환   - 모든 쿠키는 같은 방식으로 만들 수 있어요!  
I : 인터페이스분리 - 필요한 기능만 딱! 인터페이스 나누기
D : 의존역전      - 구체적인 쿠키말고, 추상적인 쿠키에 의존



● 6. 상속