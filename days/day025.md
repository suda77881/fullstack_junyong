![alt text](./img/image-65.png)


```
package com.company.java011_ex;
// 패키지 다를시 import필요

import java.util.Arrays;

//Apple [name=RED, order=iron, num=2, price=1000]
//Apple [name=GREEN, order=hulk, num=1, price=1500]
//Apple [name=GOLD, order=captain, num=3, price=2000]

public class ClassArrEx1{
	  public static void main(String[] args) {
	        Apple[] apples= new Apple[3]; 
	       
	        //위의 화면처럼 값 셋팅
	        String []name = {"RED","GREEN","GOLD"};
	        String []order = {"iron","hulk","captain"};
	        int []num = {2,1,3};
	        int []price = {1000,1500,2000};
	        
	        
	        apples[0] = new Apple("RED", "iron", 2, 1000);
	        apples[1] = new Apple("GREEN", "hulk", 1, 1500);
	        apples[2] = new Apple("GOLD", "iron", 3, 2000);
	        
	        System.out.println("ver-1 for");
	        for(int i = 0; i<apples.length; i++) {System.out.println(apples[i]);}
	        
	        System.out.println("\nver-2 향상된 for");
	        // 	한개씩 		: 배열, 객체명 
	        for ( Apple a : apples) {System.out.println(a);}
	        
	        Apple[] apples2 = new Apple[] {
	        		new Apple("RED", "iron", 2, 1000) , new Apple("GREEN", "hulk", 1, 1500)
	        		, new Apple("GOLD", "captain", 3, 2000)
	        };
	        System.out.println(Arrays.deepToString(apples2));
	        
	        
//	        for (int i = 0; i < apples.length; i++ ) {
//	        	apples[i] = new Apple(setName[i],setOrder,setNum,setPrice); 
//	        	
//	        	
//	        	apples[i].setName(name[i]);
//	        	apples[i].setNum(num[i]);
//	        	apples[i].setPrice(price[i]);
//	           
//	        }
//	        
//	        System.out.println(apple);
	        
	        
	        //위의 화면처럼 출력
	  }
	}
```

```
/* 클래스의 재사용
   Object      {         }
     ↑
  MobileNote   { show() }
     ↑
 MobileNote7   { iris,face / newShow() } 
     ↑
 MobileNote8   { ◎face     / ◎newShow() }  
     ↑
 MobileNote9   { battery   / ◎newShow() } 

----------------------------------------------
MobileNote8 my8 = new MobileNote8();
----------------------------------------------

----------------------------------------------
MobileNote7 my7 = new MobileNote7();
----------------------------------------------
1.     MobileNote7  는    MobileNote 이다.
2.     생성자호출순서 :  MobileNote7()  → MobileNote()  → Object()
3.     객체생성순서  :  Object → MobileNote → MobileNote7
       1번지 : { iris,face / newShow() } - { show() }
       
*/

```

```
연습문제2)     클래스 상속과 메서드 오버라이딩
패키지명 : com.company.java011_ex 
클래스명 : ClassEx002.java

1. 아래 조건에 맞게 ClassEx002.java 파일을 작성하고,
   main() 메서드를 수정하여 다음과 같은 출력 결과가 나오도록 하시오.
2. 주어진 코드 (수정 전)
```java
public class ClassEx002 {
    public static void main(String[] args) {
        MobileNote7 my7 = new MobileNote7();
        my7.setIris("brown");
        my7.setFace("pretty");
        my7.newShow();

        MobileNote8 my8 = new MobileNote8();
        my8.setFace("pretty");
        my8.newShow();

        MobileNote9 my9 = new MobileNote9();
        my9.setBattery(24);
        my9.newShow();
    }
}
```
3. 출력 결과 

NOTE7 객체 기능(Overriding)
iris = brown
face = pretty

NOTE8 객체 기능(Overriding) 추가
face = pretty

NOTE9 객체 기능(Overriding) 추가
battery 예쁘게 사용하기!
battery = 24

4. 클래스 구조 설명
클래스명      멤버변수        멤버메서드
MobileNote   없음                        void show()
MobileNote7   String iris, String face  void newShow()
MobileNote8   String face                 void newShow()
MobileNote9   int battery                 void newShow()
모든 멤버변수는 private으로 선언

-각 클래스는 MobileNote 클래스를 상속받음
-newShow() 메서드는 각 클래스에서 오버라이딩되어 고유한 출력 형식을 가짐

5. 요구사항
-MobileNote 클래스를 기반으로 상속 구조를 설계할 것 (MobileNote7, MobileNote8, MobileNote9 모두 상속)
-각 클래스에서 setter 메서드를 통해 멤버변수 값을 설정할 수 있도록 구현할 것
-newShow() 메서드를 오버라이딩하여 출력 형식을 문제에서 제시한 형태로 맞출 것
-출력 순서와 내용이 정확히 일치하도록 main() 메서드를 구성할 것



연습문제3)    클래스 상속과 메서드 호출 우선순위
패키지명 : com.company.java011_ex 
클래스명 : ClassEx003.java

1. 아래 조건에 맞게 ClassEx003.java 파일을 작성하고, 
   빈칸을 채운 뒤 main() 메서드를 실행하여 출력 결과를 예상하시오.
2. 주어진 코드 (수정 전)
```java
class Grand extends Object {
    public void one() { System.out.println("grand : one"); }
    public void two() { System.out.println("grand : two"); }
}
// (1) Father 클래스가 Grand 클래스를 상속받도록 수정
public class Father {
    public void three() { System.out.println("Father : three"); }
}

```
3. 출력 결과  
 
grand : one
grand : two
Father : three

4. 클래스 구조 설명
클래스명        상속 관계       주요 메서드
1) Object   최상위 클래스           -
2) Grand      Object → Grand         one(), two()
3) Father   Grand → Father       three()
4) Uncle      Object → Uncle 
5) Aunt      Object → Aunt     
- 모든 클래스는 Object 클래스를 기본적으로 상속받음
- Grand 클래스는 one()과 two() 메서드를 정의
- Father 클래스는 Grand를 상속받아 three() 메서드를 추가

5. 요구사항
- Father 클래스가 Grand 클래스를 상속받도록 extends 키워드를 활용할 것
- main() 메서드에서 Father 객체를 생성하고 one(), two(), three() 메서드를 순서대로 호출할 것
- 상속 관계에 따라 메서드 호출 우선순위를 이해하고 출력 결과를 정확히 예측할 것
- Uncle, Aunt 클래스도 Object를 상속받는 구조로 확장 가능하므로, 필요 시 추가 구현할 것


```


```

연습문제1)  멤버변수
패키지명 : com.company.java011_ex
클래스명 :   ExtendsEx001.java
1. 아래 조건에 맞게 Extends002.java 파일을 작성하고, main() 메서드를 수정하여 다음과 같은 출력 결과가 나오도록 하시오.
2. 주어진 코드 (수정 전)
```java
public class ExtendsEx001 {
    public static void main(String[] args){
        Green mygreen = new Green();
        mygreen.name = "LIGHT_GREEN";
        mygreen.num = 5;
        mygreen.show();
    }
}
```
3.출력 결과 
GREEN
NAME : LIGHT_GREEN
NUM : 5

4. 클래스 구조 설명
 Color 클래스 : 멤버 변수:  name (String, public)  / num (int, private)
  ↑
Green 클래스  : 멤버 변수:  name (String, public), num (int, private)
 

5 요구사항
1) Color와 Green 클래스의 상속 관계를 활용할 것
2) main() 메서드에서 직접 name과 num에 값을 할당할 수 있도록 접근 제어자를 고려할 것
3) show() 메서드를 통해 출력 형식을 맞출 것


```

```

package com.company.java011;

//1. 상속? 클래스의 재사용
/* 실선(확장-연결)-속이 빈 화살표(일반화)
   Object		3)			  {			Object		}	  4)
     ↑
     A	int a =10   2)			  {a	 A()		a=10} 5)
     ↑
     B	int b=20   1) new : 1번지 {b   → B()			b=20} 6)
     
     -------------------------------------------------------
     B b1 = new B(); b1.show();
     -------------------------------------------------------
     
     1) extends 상속
     2) is a : A는 Object이다, B도 Object
     3) 생성자호출 : B() → A() → Object
     4) 객체생성  : Object → A → B
     
     
 */
class A extends Object{
	int a=10;
	public A() { super(); }	
}
class B extends A	  {
	int b=20;
	public B() { super(); }
	public void show() {System.out.println(super.a+ " \t" + this.b);}
}

public class Extends001 {
	public static void main(String[] args) {
		B b1 = new B(); b1.show();
	}

}



```

```

package com.company.java011;

import java.util.Arrays;

public class ClassArr001 {
	public static void main(String[] args) {
		// 1) Toy [] 나주소 받을수 있어~
		Toy [] toys = new Toy[3];	//2) new 번지, Toy형태의 자료형 3개		
		System.out.println("1, " + toys);
		System.out.println("2, " + Arrays.toString(toys));
		
		
		toys[0] = new Toy();
		toys[0].setName("할로윈키티"); toys[0].setAge(52);
		System.out.println("3. " + toys[0] );
		
		
		// 사용방법2
		Toy [] toys2 = new Toy[] {
				new Toy("할로윈키티", 52) , new Toy("건담", 47)
		};
		// toys[0].name, toys[0].age
		// toys[1].name, toys[1].age
		
		for (int i=0; i<toys2.length; i++) { toys[i].show();}
		
		/// 클래스명의 뒷쪽에 [] 두번째 부분엔 숫자(층칸수) 선언
		///사용할땐 지역변수명[숫자]
	}
}





/*
------------------------[ runtime data area]
> Toy.class	Class_Repeat.class, Toy.company="(주) 703toyland" , Toy.num=0
------------------------------------
[heap: 동적]            | [stack : 잠깐빌리기]
1번지 [null][null][null]	<- toys [1번지]
						| 	main
		------------------------------------
*/

```






● 6. 클래스다이어그램
1. 시스템을 구성하는 클래스들 사이관계를 표현
2. 클래스 - 객체를 생성하는 설계도
3. staruml.io - 다운로드 - 설치
4. 클래스
----------------------------------------
[Animal]
----------------------------------------
add - attribute (멤버변수)
----------------------------------------
add - operation (멤버함수)
----------------------------------------

5. uml 관계
> 1) 연관관계 ( 연결 → 한쪽은 알지만, 다른쪽은 상대방의 존재는 모름 )
> 2) 일반화관계(상속, IS-A 고양이는 동물이다, 속이 빈 화살표   )
      고양이는 동물이다(O), 사람도 동물이다(O), 동물은 고양이다? (X)
> 3) 집합관계 (자동차 = 엔진 + 휠 
                ◆ 생성자안에서 new (합성)   ,   ◇ 생성자 안에서 주소(집약) )
4) 의존관계
5) 실체화관계(인터페이스)

6. SOLID 원칙 
S : 단일책임      - 한클래스는 한가지 일만해요.  (쿠키굽기)
O : 개방폐쇄      - 새로운 쿠키는 쉽게 추가 (확장가능, 수정닫힘)
L : 리스코프치환   - 모든 쿠키는 같은 방식으로 만들 수 있어요!  
I : 인터페이스분리 - 필요한 기능만 딱! 인터페이스 나누기
D : 의존역전      - 구체적인 쿠키말고, 추상적인 쿠키에 의존

![alt text](./img/image-66.png)

● 6. 상속





```

package com.company.java011;

public class Apple{   //// 실행 main과 파일을 분리해주세요!
	   private String name;
	   private String order;
	   private int num;
	   private int price;
	   
	   public String getName() { return name; } public void setName(String name) { this.name = name; } public String getOrder() { return order; } 
	   public void setOrder(String order) { this.order = order; } 
	   public int getNum() { return num; } public void setNum(int num) { this.num = num; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; }  
	}

```




JavaScript
```
<!DOCTYPE html>
<html lang="ko">
<head>
  <title>DBDBIG</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<!-- Latest compiled and minified CSS -->
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">

<!-- Latest compiled JavaScript -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</head>
<body>

<!--                                    -->
<!--                                    -->
<!--                                    -->
<!--                                    -->
<!--                                    -->
<div class="p-3 bg-primary text-white ">
  <h1>007. CONTROL</h1>
  <ol>
    <li>IF</li>
    <li>SWITCH</li>
    <li>FOR/WHILE/DO WHILE</li>
  </ol>
</div>
<!--                                    -->
<!--                                    -->
<div class="container card  my-3">
  <h3  class="card-header">007. CONTROL - Step1. IF</h3>
  <div class="card-body">
    <h4>Step1. IF</h4>
      <script>
       // if(조건){조건이 true }
       // else    {조건이 false}
        let data = 1; 
        if (data==1 ) { console.log("1이다");}
        else{ console.log("1이 아니다.");}
      </script>
  </div>
  <!--     -->
  <!--     -->
  <hr/>
  <div class="card-body">
    <h4>EX</h4>
    <pre>
      평균을 입력하세요 __입력받기
      만약 평균이 60점 이상(60점포함)이라면 합격, 아니면 불합격 출력
    </pre>
    <input type="button" value="ex1"  id="ex1"  title="버튼을 클릭하세요" class="btn btn-success"      />
    <script>

      window.addEventListener("load", function(){
        let ex1 = document.querySelector("#ex1");
        ex1.addEventListener("click", function(){

        let avg  = prompt("평균입력");
        if(avg >= 60){alert("합격");}
        else {alert("불합격")}; 

        });

      });
 
    </script>
  </div>
</div>




<!--                                    -->
<!--                                    -->
<div class="container card  my-3">
  <h3  class="card-header">007. CONTROL - Step2. SWITCH</h3>
  <div class="card-body">
    <h4>Step2. SWITCH</h4>
      <script>
      /*
      swtich(  처리하고 싶은 대상    ){
          case 대상의상태:    처리;  break;
          case 대상의상태:    처리;  break;
          case 대상의상태:    처리;  break;
          default : 기본처리
      } */
        let data2=2;
        switch(data2){
          case 1 : console.log("1이다."); break;
          case 2 : console.log("2이다."); break;
          case 3 : console.log("3이다."); break;
          default : console.log("1,2,3이 아니다")
        }
      </script>
  </div>
  <!--     -->
  <!--     -->
  <hr/>
  <div class="card-body">
    <h4>EX</h4>
    <pre>
      4,5,6 중에 입력하세요
      4번 월드콘  ,  5번 구구콘 , 6번 설레임 알림창을 띄우시오.
    </pre>
    <input type="button" value="switch1"  id="switch1"  title="버튼을 클릭하세요" class="btn btn-success"      />
    <script>

      window.addEventListener("load", function(){
        let swc = document.querySelector("#switch1");
        swc.addEventListener("click", function(){
        let chs = prompt("4,5,6 중에 입력하세요");
        switch (chs){
          case "4" : {alert("월드콘")}; break;
          case "5" : {alert("구구콘")}; break;
          case "6" : {alert("설레임")}; break;
          default: {alert("아무값도 아님")}; break;
        };

        });

      });
      
    </script>
  </div>
</div>




<!--                                    -->
<!--                                    -->
<div class="container card  my-3">
  <h3  class="card-header">007. CONTROL - Step3. FOR/WHILE/DO WHILE</h3>
  <div class="card-body">
    <h4>Step3. FOR/WHILE/DO WHILE</h4>
      <script>
      /*
        STEP1 for  - 반복횟수 알때
        for(  초기문; 조건문; 증감문 ){  }

        STEP2 while- 반복횟수 모를때
        초기문;
        while(  조건문 ){     증감문;  }

        STEP3 do while- 한번은 실행을 해야할때
        초기문;
        do{     증감문;  } while(  조건문 );

        STEP4 향상된 for
        for( index  in 객체 ){     }*/
        console.log("step1-for");
        for(let i=1; i<4; i++){console.log(i);}

        console.log("step2-while");
        let i=1;
        while( i<4){console.log(i); i++}

        console.log("step3-do-while");
        i=1;
        do{console.log(i); i++;}while( i<4);
 
        console.log("step4-향상된 for");
        const list = ['a','b','c'];
        for(let i in list ) {console.log( i + "/" + list[i]); }

        console.log("step4-향상된 for 2");
        list.forEach( (ele , index, list)=> { // e-i-l
          console.log( ele + "/" + index + "/" + list);
        } );
      </script>
  </div>
  <!--     -->
  <!--     -->
  <hr/>
  <div class="card-body">
    <h4>EX</h4>
    <pre>
    for, while, do while
    Q1)		1	2	3	4	5
    Q2)		5	4	3	2	1
    Q3)		2	4	6
    Q4)		hello1		hello2		hello3
    Q5)		const list1 = [1	2	3	4	5];
    </pre>
    <script>
      // for, while, do while
      //A1)		1	2	3	4	5
      window.addEventListener("load", function(){


        console.log("1for 1 2 3 4 5")

        for (let i = 1; i<6; i++){
          console.log(i)
        };
        console.log("1while 1 2 3 4 5")
        let i = 1;
        while ( i<6){
          console.log(i)
        i++};

        console.log("1do-while 1 2 3 4 5")
        i = 1;
        do{
          console.log(i)
        i++}while ( i<6);



      //A2)		5	4	3	2	1

      console.log("2for 5 4 3 2 1")

      for (let i = 5; i>=1; i--){
          console.log(i)
        };

      console.log("2while 5 4 3 2 1")

      i = 5;
      while ( i>=1){
          console.log(i)
         i--};

      console.log("2do-while 5 4 3 2 1")
      i = 5;
      do{
          console.log(i)
        i--}while (i>=1);
        

      //A3)		2	4	6

      console.log("3for 2 4 6")
        let num = 0;
      for (let i = 1; i<4; i++){
          num += 2;
          console.log(num)
        };

      console.log("3while 2 4 6")
        num = 0;
        i = 1;
      while (i<4){
          num += 2;
          console.log(num)
        i++};

      console.log("3do-while 2 4 6")
        num = 0;
        i = 1;
      do{
          num += 2;
          console.log(num)
        i++}while (i<4);
        

      //A4)		hello1		hello2		hello3
        
        console.log("4for		hello1		hello2		hello3")
        let word = "hello";
      for (let i = 1; i<4; i++){
          console.log(word + i)
        };

        console.log("4while		hello1		hello2		hello3")
        i = 1; 
      while (i<4){
          console.log(word + i)
         i++};

         console.log("4do-while		hello1		hello2		hello3")
        i = 1; 
      do{
          console.log(word + i)
         i++}while (i<4);
        

      // 향상된 for , forEach
      //A5)		const list1 = [1	2	3	4	5];

      console.log("향상된 for = [1	2	3	4	5]")

      const list = [1,2,3,4,5];
      console.log("[");

      
      for (i in list){
        
        console.log(list[i]);

      }
      console.log("]");


       console.log("향상된 for 2 = [1	2	3	4	5]");
       console.log("[");
        list.forEach( (ele , index, list)=> { 
          console.log( ele );
        } );
        console.log("]");
      
         });
    </script>
  </div>
</div>


</body>
</html>
```


제어문의 종류와 새로운 제어문 향상된 for와 for each?


```

<script>
      /*
        console.log("step4-향상된 for");
        const list = ['a','b','c']; // 배열선언
        for(let i in list ) {console.log( i + "/" + list[i]); } // i in list

        console.log("step4-향상된 for 2");
        list.forEach( (ele , index, list)=> { // e-i-l
          console.log( ele + "/" + index + "/" + list);
        } );
      </script>

```

상수 list = ['a','b','c']; 배열이 있을때

향상된 for문
```
const list = ['a','b','c']; // 배열선언
        for(let i in list ) {console.log( i + "/" + list[i]); } // i in list

// for (리스트를 담을 변수 in 배열변수) {수행내용};
```

for(i in list ) {   }; 배열을 `i`에 한개씩 꺼내서 담는 for문.
alert(i); 로 출력하게되면 a b c 가 차례대로 출력되는 구조가 된다.


forEach 인경우
```
list.forEach((ele, index, list) => { 
console.log(ele + "/" + index + "/" + list); });

// 배열변수.forEach (엘레멘트, 순서, 배열변수) = > {수행내용}; 
```

`i`는 인덱스 순서를 담당하고,  "list[i]"형태로 배열을 순서대로 출력




## Track001 -  github
 


# ■ Github   
### 12. 깃허브 협업 
---
1. html + css + js/jquery      [개인]
2. spring + mybatis + jstl     
3. node + react
4. spring boot + thymeleaf + jpa + mybatis + react  
5. flutter + spring boot + jpa + mybatis + react





# ■ JAVA
# ■ Java 복습문제
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
Q1. 클래스와 인스턴스의 관계를 설명하시오    
클래스는 객체를 만들기 위한 (①   설계도  ) 역할을 한다.
인스턴스는 클래스의 구조를 기반으로 (②   실체화  ) 되어 메모리에 생성된 실체이다.
같은 클래스라도 인스턴스는 서로 다른 (③  특징   ) 값을 가질 수 있다.

Q2. 다음 코드의 실행 결과와 메모리 구조를 설명하시오
```java
Car myCar = new Car("Hyundai", 2023);
```
new Car(...)는 객체를 생성하고 (④  heap   ) 영역에 저장된다.
myCar는 해당 객체의 (⑤  주소    ) 를 참조한다.
생성자 내부에서는 전달받은 값을 (⑥ 초기화    ) 한다.

Q3. 생성자에 대한 설명으로 옳은 것을 고르시오
생성자는 클래스명과 (⑦ 이름    ) 이 같아야 한다.
생성자는 객체 생성 시 자동으로 (⑧  호출   ) 된다.
생성자는 반환값이 (⑨  없다   )

Q4. 기본 생성자가 자동으로 생성되지 않는 경우는?
클래스에 (⑩  오버로딩 된   ) 생성자가 이미 정의되어 있을 경우
상속받은 클래스에서 부모 생성자 호출이 필요한 경우

Q5. 다음 코드에서 객체가 저장되는 메모리 영역과 메서드 실행 흐름을 설명하시오
```java
Book b1 = new Book("Java", 500);
Book b2 = new Book();
b2.setTitle("Spring");
```
Book 클래스의 인스턴스는 (⑪   heap  ) 영역에 저장된다.
b1, b2는 각각 객체의 (⑫   주소  ) 를 참조한다.
setTitle() 메서드는 (⑬  stack   ) 영역에서 실행된다.

Q6. 자바 메모리 구조에서 각 영역의 역할을 설명하시오
Method Area : 클래스 정보 및 static 변수 저장
Heap Area : (⑭    인스턴스 객체 ) 저장, GC가 관리
Stack Area : (⑮    지역변수 및 메서드작업공간 ) 저장, 메서드 호출 시 사용됨

Q7. 변수의 종류와 메모리 위치를 연결하시오
클래스 변수 → (⑯   method area  ) 영역
인스턴스 변수 → (⑰   heap area  ) 영역
지역 변수 → (⑱  stack area   ) 영역

Q8. 접근자를 넓은 범위에서 좁은 범위로 적으시오
(⑲  public   → ⑳   protected → ㉑   default → ㉒ private )

Q9. 다음을 private으로 설정했다. 외부에서 접근 가능하게 설정해야 하는 것
(㉓  getter / ㉔  setter ) 이다. 





# ■ Java 진행 (1)
>>>>>>>>>>>>>>>>>>>>>>  
 
● 5. 클래스배열
  클래스[]  배열명 = new 클래스[갯수];
  
  String[]   arr     = new String[3];  
  A1     []   carr   = new A1[3];  // [null, null, null ]
  ※ null  - 공간은 있지만 값이 비어있어!
   
  carr[0]  = new  A1();  ※ 생성자를 불러서 인스턴스변수를 초기화해 사용가능하게만들기
  1번지{  name="" }  ←  carr[0] 1번지




연습문제1)  클래스배열
패키지명 : com.company.java011_ex
클래스명 : ClassArrEx1
다음과 같이 코드를 작성하시오.
ㅁ출력된 화면
Apple [name=RED, order=iron, num=2, price=1000]
Apple [name=GREEN, order=hulk, num=1, price=1500]
Apple [name=GOLD, order=captain, num=3, price=2000]

ㅁ주어진 옵션
public class Apple{   //// 실행 main과 파일을 분리해주세요!
   private String name;
   private String order;
   private int num;
   private int price;
}

public class ClassArrEx1{
  public static void main(String[] args) {
        Apple[] apples= new Apple[3]; 
        //위의 화면처럼 값 셋팅
        //위의 화면처럼 출력
  }
}





연습문제2)  클래스배열
패키지명 : com.company.java011_ex
클래스명 : ClassArrEx2
다음과 같이 코드를 작성하시오.
ㅁ출력된 화면
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
이름	국어	영어	수학	평균	합격여부
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
아이언맨	100	100	100	100.0	합격
헐크	90	60	80	76.0	합격
블랙팬서	20	60	90	56.0	불합격

ㅁ주어진 옵션
public class  Score2{   //// 실행 main과 파일을 분리해주세요!
	private String name;   // 셋팅 setName() ,가져오기 getName()
	private int kor, eng, math;  // setKor , getKor /  setEng , getEng / setMath , getMath
	private double avg;
	private String pass;
}
public class ClassArrEx2 {
  public static void main(String[] args) {
	////// MODEL
	Score2[] std = new Score[3];  
	// 0번째에는 아이언맨 정보넣기  - "아이언맨", 100, 100, 100
	// 1번째에는 아이언맨 정보넣기  - "헐크", 90, 60, 80
	// 2번째에는 아이언맨 정보넣기  - "블랙팬서", 20, 60, 90
		
	////// CONTROLLER - 처리 해결사 Controller)
	Score2Process process = new Score2Process();
	process.process_avg(std); 
	process.process_pass(std); 
	process.process_pass(std);  
	
	////// VIEW       - CONSOLE , WEB
	Score2Print  print = new Score2Print();
	print.show(std);  
  }
}
 
 
● 6. 클래스다이어그램
1. 시스템을 구성하는 클래스들 사이관계를 표현
2. 클래스 - 객체를 생성하는 설계도
3. staruml.io - 다운로드 - 설치
4. 클래스
---------------------
[Animal]
---------------------
add - attribute (멤버변수)
---------------------
add - operation (멤버함수)
---------------------

5. uml 관계
>1) 연관관계  ( 연결  →  , 한쪽은 알지만, 다른쪽은 상대방의 존재는 모름 )
>2) 일반화관계(상속, IS-A 고양이는 동물이다, 속이 빈 화살표  )
     고양이는 동물이다(O) , 사람도 동물이다(O) , 동물은 고양이다? (x)   
> 3) 집합관계 (자동차 = 엔진 + 휠
              ◆  생성자안에서 new (합성)   , ◇ 생성자 안에서 주소(집약) )
4) 의존관계
5) 실체화관계(인터페이스)

6. SOLID 원칙
S : 단일책임      - 한 클래스는 한가지 일만해요. (쿠키굽기)
O : 개방폐쇄      - 새로운 쿠키는 쉽게 추가 (확장o, 수정x) 
L : 리스코프치환   - 모든쿠키는 같은방식으로 만들수 있어요!  
I : 인터페이스분리 - 필요한 기능만 딱! 인터페이스 나누기 
D : 의존역전      - 구체적인 쿠키말고, 추상적인 쿠키에 의존




● 7. 상속
1. 상속?  클래스의 재사용 - 새로운 부분만 추가, 수정해서 사용

2. super  vs  sub
  부모           자식
  상위           하위
  parent        child
  super         sub

3. 모든클래스는 Object 클래스를 상속

4. UML - 부모 ← 자식

5. 장점 - 빠른개발, 코드의 중복성제거, 다형성(하나의 타입으로 여러타입을 관리)

6. 문법
  class  자식클래스 extends 부모클래스  (O)  단일상속
  
  class  자식클래스 extends 부모클래스1, 부모클래스2 (X)

7. 상속시 부모속성을 사용할수 있는 이유?
   - 부모생성자를 호출해 
     부모의 인스턴스변수를 초기화해 사용가능하게 만들어줌.

8. 오버라이드
  - @Override
  - 상속(extends)시  부모의 메서드와 동일한지


연습문제1)  멤버변수
패키지명 : com.company.java011_ex
클래스명 :   ExtendsEx001.java
1. 아래 조건에 맞게 Extends002.java 파일을 작성하고, main() 메서드를 수정하여 다음과 같은 출력 결과가 나오도록 하시오.
2. 주어진 코드 (수정 전)
```java
public class ExtendsEx001 {
    public static void main(String[] args){
        Green mygreen = new Green();
        mygreen.name = "LIGHT_GREEN";
        mygreen.num = 5;
        mygreen.show();
    }
}
```
3.출력 결과 
GREEN
NAME : LIGHT_GREEN
NUM : 5

4. 클래스 구조 설명
 Color 클래스 : 멤버 변수:  name (String, public)  / num (int, private)
  ↑
Green 클래스   
 

5 요구사항
1) Color와 Green 클래스의 상속 관계를 활용할 것
2) main() 메서드에서 직접 name과 num에 값을 할당할 수 있도록 접근 제어자를 고려할 것
3) show() 메서드를 통해 출력 형식을 맞출 것



연습문제2)     클래스 상속과 메서드 오버라이딩
패키지명 : com.company.java011_ex 
클래스명 : ClassEx002.java

1. 아래 조건에 맞게 ClassEx002.java 파일을 작성하고,
   main() 메서드를 수정하여 다음과 같은 출력 결과가 나오도록 하시오.
2. 주어진 코드 (수정 전)
```java
public class ClassEx002 {
    public static void main(String[] args) {
        MobileNote7 my7 = new MobileNote7();
        my7.setIris("brown");
        my7.setFace("pretty");
        my7.newShow();

        MobileNote8 my8 = new MobileNote8();
        my8.setFace("pretty");
        my8.newShow();

        MobileNote9 my9 = new MobileNote9();
        my9.setBattery(24);
        my9.newShow();
    }
}
```
3. 출력 결과 

NOTE7 객체 기능(Overriding)
iris = brown
face = pretty

NOTE8 객체 기능(Overriding) 추가
face = pretty

NOTE9 객체 기능(Overriding) 추가
battery 예쁘게 사용하기!
battery = 24

4. 클래스 구조 설명
클래스명      멤버변수        멤버메서드
MobileNote   없음                        void show()
MobileNote7   String iris, String face  void newShow()
MobileNote8   String face                 void newShow()
MobileNote9   int battery                 void newShow()
모든 멤버변수는 private으로 선언

-각 클래스는 MobileNote 클래스를 상속받음
-newShow() 메서드는 각 클래스에서 오버라이딩되어 고유한 출력 형식을 가짐

5. 요구사항
-MobileNote 클래스를 기반으로 상속 구조를 설계할 것 (MobileNote7, MobileNote8, MobileNote9 모두 상속)
-각 클래스에서 setter 메서드를 통해 멤버변수 값을 설정할 수 있도록 구현할 것
-newShow() 메서드를 오버라이딩하여 출력 형식을 문제에서 제시한 형태로 맞출 것
-출력 순서와 내용이 정확히 일치하도록 main() 메서드를 구성할 것



연습문제3)    클래스 상속과 메서드 호출 우선순위
패키지명 : com.company.java011_ex 
클래스명 : ClassEx003.java

1. 아래 조건에 맞게 ClassEx003.java 파일을 작성하고, 
   빈칸을 채운 뒤 main() 메서드를 실행하여 출력 결과를 예상하시오.
2. 주어진 코드 (수정 전)
```java
class Grand extends Object {
    public void one() { System.out.println("grand : one"); }
    public void two() { System.out.println("grand : two"); }
}
// (1) Father 클래스가 Grand 클래스를 상속받도록 수정
public class Father {
    public void three() { System.out.println("Father : three"); }
}

```
3. 출력 결과  
 
grand : one
grand : two
Father : three

4. 클래스 구조 설명
클래스명        상속 관계       주요 메서드
1) Object   최상위 클래스           -
2) Grand      Object → Grand         one(), two()
3) Father   Grand → Father       three()
4) Uncle      Object → Uncle 
5) Aunt      Object → Aunt     
- 모든 클래스는 Object 클래스를 기본적으로 상속받음
- Grand 클래스는 one()과 two() 메서드를 정의
- Father 클래스는 Grand를 상속받아 three() 메서드를 추가

5. 요구사항
- Father 클래스가 Grand 클래스를 상속받도록 extends 키워드를 활용할 것
- main() 메서드에서 Father 객체를 생성하고 one(), two(), three() 메서드를 순서대로 호출할 것
- 상속 관계에 따라 메서드 호출 우선순위를 이해하고 출력 결과를 정확히 예측할 것
- Uncle, Aunt 클래스도 Object를 상속받는 구조로 확장 가능하므로, 필요 시 추가 구현할 것







# ■ JAVA
# ■ JAVA 복습문제
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> 
Q1. 다음과 같이 코드를 작성하시오.

public class ClassArrEx1{
  public static void main(String[] args) {
        Apple[] apples= new Apple[3]; 
        // 화면처럼 값 셋팅
        // 화면처럼 출력
  }
}

ㅁ출력된 화면
Apple [name=RED, order=iron, num=2, price=1000]
Apple [name=GREEN, order=hulk, num=1, price=1500]
Apple [name=GOLD, order=captain, num=3, price=2000]

```java
     
        
        Apple[] apples= new Apple[] { 
        		new Apple("RED" , "iron" , 2 , 1000) ,  new Apple("GREEN" , "hulk" , 1 , 1500)
        		,new Apple("GOLD" , "captain" , 3 , 2000)
        };

      for( Apple   a  :  apples ) { System.out.println(a);  }
```




Q2. 상속도를 달고 다음에 답변을 달으시오.   

 class Grand extends Object {
    public void one() { System.out.println("Grand : one"); }
    public void two() { System.out.println("Grand : two"); }
}
class Father extends Grand {
    public void three() { System.out.println("Father : three"); }
}
class Uncle extends Grand{
    public void four(){ System.out.println("Uncle : four"); }
    @Override public void one() { System.out.println("Uncle : one"); }  ##
    @Override public void two() { System.out.println("Uncle : two"); }  ##
}
 
public class ClassEx003 {
	public static void main(String[] args) {
		Father papa  = new Father(); papa.one();   papa.two();  papa.three();
		Uncle  uncle = new Uncle(); uncle.four();  uncle.one();  uncle.two();  
		//Q1. uncle이 쓸수 있는 메서드는?      
		//Q2. 24번째줄에서 출력되는 내용은?   
		//Q3.  개념은?  
	}
}

```
		//Q1. uncle이 쓸수 있는 메서드는?      Uncle { one() ,two() ,four()  } →   Grand{ one() ,two()  }
		//Q2. 24번째줄에서 출력되는 내용은?   Uncle { @one() ,@two() ,four()  } →   Grand{ one() ,two()  }
		//Q3.  개념은? 오버라이딩: 상속시 부모와 같은 메서드를 자식클래스에 맞게 수정한것!
```