```java

package com.company.java015_labmda_stream;

//1. 클래스는 부품객체 - 설계도(틀, can do this~!)
//2. 상태 + 행위     - interface( public static final  / public abstract  )
///////////////////////////////////////////////////////////////////////////
interface Inter1{  void method();   }
class Inter1Impl implements Inter1{ 
	@Override public void method() { System.out.println("Hello :D"); }
}
///////////////////////////////////////////////////////////////////////////
public class Lambda001 {
	public static void main(String[] args) {
		//#1. interface  구현객체(자식)
		// 부모	  = 자식
		Inter1 i1 = new Inter1Impl();  i1.method();
		//#2. 익명이너클래스 ( test목적, 1번쓰고 버릴목적, 잘안쓰는 이벤트 )
		// Inter1 i2  = new Inter1();  interface 는 추상메서드이기때문에 new사용못함.
		Inter1 i21  = new Inter1() { 
			@Override public void method() { System.out.println("일회용-Hello :D"); }
		}; i21.method();
		Inter1 i22  = new Inter1() { 
			@Override public void method() { System.out.println("일회용-Hello :D"); }
		}; i22.method();
		//#3. lambda 
		
		Inter1 i3 = () -> { System.out.println("줄이기~! Hello :D:D:D");};
		i3.method();
	}
}

```
package com.company.java015_labmda_stream;

////////////////////////////////////////////////////////////
interface InterA2{  void   hi(); }
interface InterB2{  void   hi(String name); }
interface InterC2{  String hi(); }
interface InterD2{  void   hi(int num , String name); }
////////////////////////////////////////////////////////////
public class Lambda002 {
	public static void main(String[] args) {
		//interface InterA2{  void hi(); }
		System.out.println("\n\n[STEP1] 매개변수 X, 리턴값 X");  // InterA2
		//1-1. 익명객체 hi출력
		InterA2  a = new InterA2() {
			@Override public void hi() { System.out.println("hi"); }
		}; a.hi();
		//1-2. 람다식 ()->{}
		InterA2  a2 = ()->{ System.out.println("hi2"); };  a2.hi();
		InterA2  a3 = ()->  System.out.println("hi3");     a3.hi(); //처리할일이 한줄 {}생략
		
		// interface InterB2{  void hi(String name); } 
		System.out.println("\n\n[STEP2] 매개변수 O, 리턴값 X"); 
		//2-1. 익명객체 hi sally!출력
		InterB2 b = new InterB2() {
			@Override public void hi(String name) { System.out.println("hi! " + name); }
		}; b.hi("sally");
		//2-2. 람다식 ()->{}
		InterB2 b2 = (String name)->{ System.out.println("hi! " + name); };
		b2.hi("alpha");
		InterB2 b3 = (name)->{ System.out.println("hi! " + name); };
		b3.hi("buja");
		InterB2 b4 =  name ->  System.out.println("hi! " + name);  
		b4.hi("빨강이");
		

		// interface InterC2{  String hi(); } 
		System.out.println("\n\n[STEP3] 매개변수X , 리턴값 O"); 
		//3-1. 익명객체 Good :Day출력
		InterC2 c = new InterC2() {
			@Override public String hi() { return "Good :Day"; } 
		};  
		System.out.println( c.hi() );
		
		//3-2. 람다식  ()->{}
		InterC2 c2 = ()->{ return "G:ood Day"; };
		System.out.println(c2.hi());

		InterC2 c3 = ()->  "G:ood :Day";  
		System.out.println(c3.hi());
		
		//interface InterD2{  void   hi(int num , String name); }
		System.out.println("\n\n[STEP4] 매개변수O , 리턴값 O"); 
		//4-1. 익명객체  
		InterD2 d = new InterD2() {
			@Override
			public String toString(int num, String name) {
				String star = "";
				for(int i=0; i<num; i++) {
					star += "★";
					return "Lambda002 []";
				}
				
			}
		};
		
		System.out.println(d.hi( 1, "sally" ));  //hi sally ★★★           
		System.out.println(d.hi( 2, "sally" ));  //hi sally ★★★★      
		
		//4-2. 람다식  ()->{}
		
		InterD2 d3 = (num, name)-> {
			String star = "";
			for(int i=0; i<num; i++) {star += "★";}
			return "hi " + name + star;			
		};
		System.out.println(d3.hi( 5, "buja" ));  //hi alpha sally ★★★          
		System.out.println(d3.hi( 6, "buja" ));  //hi alpha sally ★★★★  
		

	}
}








```java
package com.company.java015_labmda_stream;

////////////////////////////////////////////////////////////
interface InterA2{  void   hi(); }
interface InterB2{  void   hi(String name); }
interface InterC2{  String hi(); }
interface InterD2{  void   hi(int num , String name); }
////////////////////////////////////////////////////////////
public class Lambda002 {
	public static void main(String[] args) {
		//interface InterA2{  void hi(); }
		System.out.println("\n\n[STEP1] 매개변수 X, 리턴값 X");  // InterA2
		//1-1. 익명객체 hi출력
		InterA2  a = new InterA2() {
			@Override public void hi() { System.out.println("hi"); }
		}; a.hi();
		//1-2. 람다식 ()->{}
		InterA2  a2 = ()->{ System.out.println("hi2"); };  a2.hi();
		InterA2  a3 = ()->  System.out.println("hi3");     a3.hi(); //처리할일이 한줄 {}생략
		
		// interface InterB2{  void hi(String name); } 
		System.out.println("\n\n[STEP2] 매개변수 O, 리턴값 X"); 
		//2-1. 익명객체 hi sally!출력
		InterB2 b = new InterB2() {
			@Override public void hi(String name) { System.out.println("hi! " + name); }
		}; b.hi("sally");
		//2-2. 람다식 ()->{}
		InterB2 b2 = (String name)->{ System.out.println("hi! " + name); };
		b2.hi("alpha");
		InterB2 b3 = (name)->{ System.out.println("hi! " + name); };
		b3.hi("buja");
		InterB2 b4 =  name ->  System.out.println("hi! " + name);  
		b4.hi("빨강이");
		

		// interface InterC2{  String hi(); } 
		System.out.println("\n\n[STEP3] 매개변수X , 리턴값 O"); 
		//3-1. 익명객체 Good :Day출력
		InterC2 c = new InterC2() {
			@Override public String hi() { return "Good :Day"; } 
		};  
		System.out.println( c.hi() );
		
		//3-2. 람다식  ()->{}
		InterC2 c2 = ()->{ return "G:ood Day"; };
		System.out.println(c2.hi());

		InterC2 c3 = ()->  "G:ood :Day";  
		System.out.println(c3.hi());
		
		//interface InterD2{  void   hi(int num , String name); }
		System.out.println("\n\n[STEP4] 매개변수O , 리턴값 O"); 
		//4-1. 익명객체  
		InterD2 d = new InterD2() {
			@Override
			public String toString(int num, String name) {
				String star = "";
				for(int i=0; i<num; i++) {
					star += "★";
					return "Lambda002 []";
				}
				
			}
		};
		
		System.out.println(d.hi( 1, "sally" ));  //hi sally ★★★           
		System.out.println(d.hi( 2, "sally" ));  //hi sally ★★★★      
		
		//4-2. 람다식  ()->{}
		
		InterD2 d3 = (num, name)-> {
			String star = "";
			for(int i=0; i<num; i++) {star += "★";}
			return "hi " + name + star;			
		};
		System.out.println(d3.hi( 5, "buja" ));  //hi alpha sally ★★★          
		System.out.println(d3.hi( 6, "buja" ));  //hi alpha sally ★★★★  
		

	}
}








```



```java
package com.company.java015_labmda_stream;

class RefClass{		void method(String str) {System.out.println(str);}	}
interface InterUsing{ void inter( RefClass c , String str);	}

public class Lambda003 {
	public static void main(String[] args) {
		//#1. 익명클래스
		InterUsing a1 = new InterUsing() {
			
			@Override public void inter(RefClass c, String str) {c.method(str);}
		};
//		InterUsing a0 = new InterUsing() {
//		
//		c.inter( new RefClass(), "Hello :)");
//		};
		
		
		// InterUsing a1 = (RefClass c, String str)-> {c.method(str);};
		//#2. 람다 ()->{} - [RefClass 클래스] 의 [method 사용]
		//InterUsing a2 = (RefClass c, String str)->{	c.method(str);	};	// 자료형 생략가능
		InterUsing 	 a2 = (	        c,		  str)->{	c.method(str);	};  // 직접 구현
		a1.inter( new RefClass() , "Hello :):)");	// RefClass클래스의 method 사용

		//#3. :: 표현식 (참조)
		InterUsing 	 a3 = 	RefClass::method; //단축 가능		//  자동연결 1) RefClass 2) method
		a3.inter( new RefClass(), "Hello :):):)");
		
		//#4. interface InterBasic{ int method(int a, int b);}
		InterBasic basic = (int a, int b) -> { return Math.max(a, b); }; // Math.max 둘중에 하나 큰거 리턴
		System.out.println(basic.method(10,3));
		
		InterBasic basic2 = (a, b) -> Math.max(a, b); // 자료형 생략가능 리턴값 한줄이면 return, {} 구현부 생략가능
		System.out.println(basic2.method(100,3));
		
		InterBasic basic3 = Math::max; // :: 쓰면 또 생략가능 (리턴값 파라미터?)
		System.out.println(basic3.method(1000,3));
		
		InterBasic basic4 = (a,b)-> Math.min(a, b); // () -> return  뭘받아서 뭘 처리해줄게 패턴만 숙지하면됨
		System.out.println(basic4.method(10, 3));
		
		InterBasic basic5 = Math::min; // ()-> return
		System.out.println(basic5.method(10, 3));
		
		////////////
		//#4. interface					//순서2 ) 어떤클래스 갖고선 어떤거 사용했다.
		InterString basic6 = (a,b) -> a.compareTo(b);	// java.lang.String.compareTo
		System.out.println( basic6.compare("apple", "banana"));	// 음수
		// 문자열이 같으면 0 , a<b 앞 글자 "a"<"b", a가 b보다 앞에온다.(작은것, 음수가 나오는경우), (양수 반환) a>b a가 b보다 뒤에옴
		

		InterString basic7 = String::compareTo;	// java.lang.String.compareTo 순서3)
		System.out.println( basic7.compare("coconut", "banana"));	// 양수
		// 문자열이 같으면 0 , a<b 앞 글자 "c">"b", a가 b보다 (양수 반환) a>b a가 b보다 뒤에옴
		
		InterParse basic8 = s -> Integer.parseInt(s); //Integer paseInt
		System.out.println( basic8.parse("10") + 3);  //13
		
		InterParse basic9 = Integer::parseInt; //Integer parseInt
		System.out.println( basic9.parse("10") + 3);  //13
		
//		InterAbs basic10 = (a)-> {return Math.abs(a);}; // 절대값 반환 = 10 , Math abs 사용
//		InterAbs basic10 =  a ->          Math.abs(a);  // 절대값 10
		InterAbs basic10 =  Math::abs;
		System.out.println( basic10.apply(-10));
		
		//InterPrint basic11 = (s) -> {	System.out.println("Hello Lambda");	};
//		InterPrint basic11 = s -> 	System.out.println(s);
		InterPrint basic11 = System.out::println;	//System.out    println
		basic11.print("Hello Lambda");
		
		// ex1) 람다식을 구현해주세요
		// 힌트 ) System.out.println("hi".length());
		//System.out.println(ex1.getLength("hello"));
		
//		Ex1 ex1 = (s)-> s.length();
		Ex1 ex1 = String::length;
		System.out.println(ex1.getLength("hello")); // 결과 5
		
//		Ex1 ex1 = System.out::println;
//		System.out.println(ex1.getLength("hello"));
		
		// ex2) 람다식을 구현해주세요
		// ex2.getLength("lambda:)");				//결과 출력 - 		lambda:)
		// Ex2 ex2 = (String s) -> {System.err.println(s);};
		Ex2 ex2 = s -> System.out.println(s);
		ex2.print("lambda:) ");					//결과 lambda:)
//		Ex2 ex2.print("");};
		
		
	}
}


interface InterBasic { int method(int a, int b);	    } //(a,b) -> return
interface InterString{ int compare(String a, String b); } //순서1) (a,b) -> return
interface InterParse { int parse(String s);				} //(s) -> return 
interface InterAbs 	 { int apply(int a);				} //(a) -> return
interface InterPrint { void print(String s);				} //(a) -> return
		
interface Ex1        {int getLength (String s); };
interface Ex2 		 {void print(String s); };

```

## Track 001 - github
# ■ 자바
# ■ 깃허브(협업)
# ■ oracle
# ■ 네트워크관리사 - 이론(2) / 실기


1. -------------
# ■ 자바
# ■ Lambda (1)


2. -------------
# ■ 자바
# ■ 깃허브(협업)
# 1. fetch
# 2. restore


-------------
# ■ oracle
# 1. 복습문제
# 2. function 

-------------
# ■ oracle
# ■ 


##### ■3. merge vs rebase
1. 기능 브랜치에서 




##### ■4. fetch vs pull
- fetch : 데이터 가져오기 ( 충돌이 날지 먼저 확인 )
- pull  : 데이터 가져오고 바로 합치기 (위험의 가능성)


```bash
#1. [ github ] test2.md 새로운 사항 업데이트
#2. [local] 작업 - 새로운 변경사항 있는지 확인
    git fetch origin
#3. 가져온 변경사항 확인
    git log  b338f42..7f69fce # fetch시에 나온번호
    git log  HEAD..origin/master    # 변경된 내용 파일 요약 확인
    git diff HEAD  origin/master    # 변경된 내용 파일 상세 확인 바이너리 (선택사항)
#4. 확인후 합치기
    git merge origin/master         # 파일 합치기
..................................................
Q1. 팀장 - [깃허브] test2.md   
    ★ 자격증 공부 
    - day001 이론완료 : 이름붙여주기

Q2. 팀원 - [깃허브] test2.md 수정 - git pull 이 아니라 
    - git fetch로 데이터 가져오기

Q3. 팀장 + 팀원 - rebase 해서 파일 다시 올리기




```

##### ■4. restore  vs  checkout
- restore  : 파일을 예전 상태로 되돌리는 기능  (최근상태로 되돌리기) , commit 안했을때사용가능
- checkout : 브랜치 바꾸거나 파일 되돌리기

``` bash
git restore  파일명   # 마지막으로 저장한상태로 돌아감.
git restore   --source=HEAD~1  파일명   # HEAD~1  1단계  , HEAD~2  2단계
```

Q1. day034.md - restore 2번 commit 하고 1번째 시점으로 돌아가기
    first     - commit 
    second    - commit 
...............................................