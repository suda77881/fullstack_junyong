```java

package com.company.java015_labmda_stream;

//1. 클래스는 부품객체 - 설계도(틀, can do this~!)
//2. 상태 + 행위     - interface( public static final  / public abstract  )
///////////////////////////////////////////////////////////////////////////
interface Inter1{  void method();   }
class Inter1Impl implements Inter1{ 
	@Override public void method() { System.out.println("Hello :D"); }
}
///////////////////////////////////////////////////////////////////////////
public class Lambda001 {
	public static void main(String[] args) {
		//#1. interface  구현객체(자식)
		// 부모	  = 자식
		Inter1 i1 = new Inter1Impl();  i1.method();
		//#2. 익명이너클래스 ( test목적, 1번쓰고 버릴목적, 잘안쓰는 이벤트 )
		// Inter1 i2  = new Inter1();  interface 는 추상메서드이기때문에 new사용못함.
		Inter1 i21  = new Inter1() { 
			@Override public void method() { System.out.println("일회용-Hello :D"); }
		}; i21.method();
		Inter1 i22  = new Inter1() { 
			@Override public void method() { System.out.println("일회용-Hello :D"); }
		}; i22.method();
		//#3. lambda 
		
		Inter1 i3 = () -> { System.out.println("줄이기~! Hello :D:D:D");};
		i3.method();
	}
}

```
```
package com.company.java015_labmda_stream;

////////////////////////////////////////////////////////////
interface InterA2{  void   hi(); }
interface InterB2{  void   hi(String name); }
interface InterC2{  String hi(); }
interface InterD2{  void   hi(int num , String name); }
////////////////////////////////////////////////////////////
public class Lambda002 {
	public static void main(String[] args) {
		//interface InterA2{  void hi(); }
		System.out.println("\n\n[STEP1] 매개변수 X, 리턴값 X");  // InterA2
		//1-1. 익명객체 hi출력
		InterA2  a = new InterA2() {
			@Override public void hi() { System.out.println("hi"); }
		}; a.hi();
		//1-2. 람다식 ()->{}
		InterA2  a2 = ()->{ System.out.println("hi2"); };  a2.hi();
		InterA2  a3 = ()->  System.out.println("hi3");     a3.hi(); //처리할일이 한줄 {}생략
		
		// interface InterB2{  void hi(String name); } 
		System.out.println("\n\n[STEP2] 매개변수 O, 리턴값 X"); 
		//2-1. 익명객체 hi sally!출력
		InterB2 b = new InterB2() {
			@Override public void hi(String name) { System.out.println("hi! " + name); }
		}; b.hi("sally");
		//2-2. 람다식 ()->{}
		InterB2 b2 = (String name)->{ System.out.println("hi! " + name); };
		b2.hi("alpha");
		InterB2 b3 = (name)->{ System.out.println("hi! " + name); };
		b3.hi("buja");
		InterB2 b4 =  name ->  System.out.println("hi! " + name);  
		b4.hi("빨강이");
		

		// interface InterC2{  String hi(); } 
		System.out.println("\n\n[STEP3] 매개변수X , 리턴값 O"); 
		//3-1. 익명객체 Good :Day출력
		InterC2 c = new InterC2() {
			@Override public String hi() { return "Good :Day"; } 
		};  
		System.out.println( c.hi() );
		
		//3-2. 람다식  ()->{}
		InterC2 c2 = ()->{ return "G:ood Day"; };
		System.out.println(c2.hi());

		InterC2 c3 = ()->  "G:ood :Day";  
		System.out.println(c3.hi());
		
		//interface InterD2{  void   hi(int num , String name); }
		System.out.println("\n\n[STEP4] 매개변수O , 리턴값 O"); 
		//4-1. 익명객체  
		InterD2 d = new InterD2() {
			@Override
			public String toString(int num, String name) {
				String star = "";
				for(int i=0; i<num; i++) {
					star += "★";
					return "Lambda002 []";
				}
				
			}
		};
		
		System.out.println(d.hi( 1, "sally" ));  //hi sally ★★★           
		System.out.println(d.hi( 2, "sally" ));  //hi sally ★★★★      
		
		//4-2. 람다식  ()->{}
		
		InterD2 d3 = (num, name)-> {
			String star = "";
			for(int i=0; i<num; i++) {star += "★";}
			return "hi " + name + star;			
		};
		System.out.println(d3.hi( 5, "buja" ));  //hi alpha sally ★★★          
		System.out.println(d3.hi( 6, "buja" ));  //hi alpha sally ★★★★  
		

	}
}








```java
package com.company.java015_labmda_stream;

////////////////////////////////////////////////////////////
interface InterA2{  void   hi(); }
interface InterB2{  void   hi(String name); }
interface InterC2{  String hi(); }
interface InterD2{  void   hi(int num , String name); }
////////////////////////////////////////////////////////////
public class Lambda002 {
	public static void main(String[] args) {
		//interface InterA2{  void hi(); }
		System.out.println("\n\n[STEP1] 매개변수 X, 리턴값 X");  // InterA2
		//1-1. 익명객체 hi출력
		InterA2  a = new InterA2() {
			@Override public void hi() { System.out.println("hi"); }
		}; a.hi();
		//1-2. 람다식 ()->{}
		InterA2  a2 = ()->{ System.out.println("hi2"); };  a2.hi();
		InterA2  a3 = ()->  System.out.println("hi3");     a3.hi(); //처리할일이 한줄 {}생략
		
		// interface InterB2{  void hi(String name); } 
		System.out.println("\n\n[STEP2] 매개변수 O, 리턴값 X"); 
		//2-1. 익명객체 hi sally!출력
		InterB2 b = new InterB2() {
			@Override public void hi(String name) { System.out.println("hi! " + name); }
		}; b.hi("sally");
		//2-2. 람다식 ()->{}
		InterB2 b2 = (String name)->{ System.out.println("hi! " + name); };
		b2.hi("alpha");
		InterB2 b3 = (name)->{ System.out.println("hi! " + name); };
		b3.hi("buja");
		InterB2 b4 =  name ->  System.out.println("hi! " + name);  
		b4.hi("빨강이");
		

		// interface InterC2{  String hi(); } 
		System.out.println("\n\n[STEP3] 매개변수X , 리턴값 O"); 
		//3-1. 익명객체 Good :Day출력
		InterC2 c = new InterC2() {
			@Override public String hi() { return "Good :Day"; } 
		};  
		System.out.println( c.hi() );
		
		//3-2. 람다식  ()->{}
		InterC2 c2 = ()->{ return "G:ood Day"; };
		System.out.println(c2.hi());

		InterC2 c3 = ()->  "G:ood :Day";  
		System.out.println(c3.hi());
		
		//interface InterD2{  void   hi(int num , String name); }
		System.out.println("\n\n[STEP4] 매개변수O , 리턴값 O"); 
		//4-1. 익명객체  
		InterD2 d = new InterD2() {
			@Override
			public String toString(int num, String name) {
				String star = "";
				for(int i=0; i<num; i++) {
					star += "★";
					return "Lambda002 []";
				}
				
			}
		};
		
		System.out.println(d.hi( 1, "sally" ));  //hi sally ★★★           
		System.out.println(d.hi( 2, "sally" ));  //hi sally ★★★★      
		
		//4-2. 람다식  ()->{}
		
		InterD2 d3 = (num, name)-> {
			String star = "";
			for(int i=0; i<num; i++) {star += "★";}
			return "hi " + name + star;			
		};
		System.out.println(d3.hi( 5, "buja" ));  //hi alpha sally ★★★          
		System.out.println(d3.hi( 6, "buja" ));  //hi alpha sally ★★★★  
		

	}
}








```



```java
package com.company.java015_labmda_stream;

class RefClass{		void method(String str) {System.out.println(str);}	}
interface InterUsing{ void inter( RefClass c , String str);	}

public class Lambda003 {
	public static void main(String[] args) {
		//#1. 익명클래스
		InterUsing a1 = new InterUsing() {
			
			@Override public void inter(RefClass c, String str) {c.method(str);}
		};
//		InterUsing a0 = new InterUsing() {
//		
//		c.inter( new RefClass(), "Hello :)");
//		};
		
		
		// InterUsing a1 = (RefClass c, String str)-> {c.method(str);};
		//#2. 람다 ()->{} - [RefClass 클래스] 의 [method 사용]
		//InterUsing a2 = (RefClass c, String str)->{	c.method(str);	};	// 자료형 생략가능
		InterUsing 	 a2 = (	        c,		  str)->{	c.method(str);	};  // 직접 구현
		a1.inter( new RefClass() , "Hello :):)");	// RefClass클래스의 method 사용

		//#3. :: 표현식 (참조)
		InterUsing 	 a3 = 	RefClass::method; //단축 가능		//  자동연결 1) RefClass 2) method
		a3.inter( new RefClass(), "Hello :):):)");
		
		//#4. interface InterBasic{ int method(int a, int b);}
		InterBasic basic = (int a, int b) -> { return Math.max(a, b); }; // Math.max 둘중에 하나 큰거 리턴
		System.out.println(basic.method(10,3));
		
		InterBasic basic2 = (a, b) -> Math.max(a, b); // 자료형 생략가능 리턴값 한줄이면 return, {} 구현부 생략가능
		System.out.println(basic2.method(100,3));
		
		InterBasic basic3 = Math::max; // :: 쓰면 또 생략가능 (리턴값 파라미터?)
		System.out.println(basic3.method(1000,3));
		
		InterBasic basic4 = (a,b)-> Math.min(a, b); // () -> return  뭘받아서 뭘 처리해줄게 패턴만 숙지하면됨
		System.out.println(basic4.method(10, 3));
		
		InterBasic basic5 = Math::min; // ()-> return
		System.out.println(basic5.method(10, 3));
		
		////////////
		//#4. interface					//순서2 ) 어떤클래스 갖고선 어떤거 사용했다.
		InterString basic6 = (a,b) -> a.compareTo(b);	// java.lang.String.compareTo
		System.out.println( basic6.compare("apple", "banana"));	// 음수
		// 문자열이 같으면 0 , a<b 앞 글자 "a"<"b", a가 b보다 앞에온다.(작은것, 음수가 나오는경우), (양수 반환) a>b a가 b보다 뒤에옴
		

		InterString basic7 = String::compareTo;	// java.lang.String.compareTo 순서3)
		System.out.println( basic7.compare("coconut", "banana"));	// 양수
		// 문자열이 같으면 0 , a<b 앞 글자 "c">"b", a가 b보다 (양수 반환) a>b a가 b보다 뒤에옴
		
		InterParse basic8 = s -> Integer.parseInt(s); //Integer paseInt
		System.out.println( basic8.parse("10") + 3);  //13
		
		InterParse basic9 = Integer::parseInt; //Integer parseInt
		System.out.println( basic9.parse("10") + 3);  //13
		
//		InterAbs basic10 = (a)-> {return Math.abs(a);}; // 절대값 반환 = 10 , Math abs 사용
//		InterAbs basic10 =  a ->          Math.abs(a);  // 절대값 10
		InterAbs basic10 =  Math::abs;
		System.out.println( basic10.apply(-10));
		
		//InterPrint basic11 = (s) -> {	System.out.println("Hello Lambda");	};
//		InterPrint basic11 = s -> 	System.out.println(s);
		InterPrint basic11 = System.out::println;	//System.out    println
		basic11.print("Hello Lambda");
		
		// ex1) 람다식을 구현해주세요
		// 힌트 ) System.out.println("hi".length());
		//System.out.println(ex1.getLength("hello"));
		
//		Ex1 ex1 = (s)-> s.length();
		Ex1 ex1 = String::length;
		System.out.println(ex1.getLength("hello")); // 결과 5
		
//		Ex1 ex1 = System.out::println;
//		System.out.println(ex1.getLength("hello"));
		
		// ex2) 람다식을 구현해주세요
		// ex2.getLength("lambda:)");				//결과 출력 - 		lambda:)
		// Ex2 ex2 = (String s) -> {System.err.println(s);};
		Ex2 ex2 = s -> System.out.println(s);
		ex2.print("lambda:) ");					//결과 lambda:)
//		Ex2 ex2.print("");};
		
		
	}
}


interface InterBasic { int method(int a, int b);	    } //(a,b) -> return
interface InterString{ int compare(String a, String b); } //순서1) (a,b) -> return
interface InterParse { int parse(String s);				} //(s) -> return 
interface InterAbs 	 { int apply(int a);				} //(a) -> return
interface InterPrint { void print(String s);				} //(a) -> return
		
interface Ex1        {int getLength (String s); };
interface Ex2 		 {void print(String s); };

```

## Track 001 - github
# ■ 자바
# ■ 깃허브(협업)
# ■ oracle
# ■ 네트워크관리사 - 이론(2) / 실기


1. -------------
# ■ 자바
# ■ Lambda (1)


2. -------------
# ■ 자바
# ■ 깃허브(협업)
# 1. fetch
# 2. restore


-------------
# ■ oracle
# 1. 복습문제
# 2. function 

-------------
# ■ oracle
# ■ 


##### ■3. merge vs rebase
1. 기능 브랜치에서 




##### ■4. fetch vs pull
- fetch : 데이터 가져오기 ( 충돌이 날지 먼저 확인 )
- pull  : 데이터 가져오고 바로 합치기 (위험의 가능성)


```bash
#1. [ github ] test2.md 새로운 사항 업데이트
#2. [local] 작업 - 새로운 변경사항 있는지 확인
    git fetch origin
#3. 가져온 변경사항 확인
    git log  b338f42..7f69fce # fetch시에 나온번호
    git log  HEAD..origin/master    # 변경된 내용 파일 요약 확인
    git diff HEAD  origin/master    # 변경된 내용 파일 상세 확인 바이너리 (선택사항)
#4. 확인후 합치기
    git merge origin/master         # 파일 합치기
..................................................
Q1. 팀장 - [깃허브] test2.md   
    ★ 자격증 공부 
    - day001 이론완료 : 이름붙여주기

Q2. 팀원 - [깃허브] test2.md 수정 - git pull 이 아니라 
    - git fetch로 데이터 가져오기

Q3. 팀장 + 팀원 - rebase 해서 파일 다시 올리기




```

##### ■4. restore  vs  checkout
- restore  : 파일을 예전 상태로 되돌리는 기능  (최근상태로 되돌리기) , commit 안했을때사용가능
- checkout : 브랜치 바꾸거나 파일 되돌리기

``` bash
git restore  파일명   # 마지막으로 저장한상태로 돌아감.
git restore   --source=HEAD~1  파일명   # HEAD~1  1단계  , HEAD~2  2단계
```

Q1. day034.md - restore 2번 commit 하고 1번째 시점으로 돌아가기
    first     - commit 

...............................................



# ORACLE SQL

내용정리

함수

to_char = 문자열로 변환 
to_number = 숫자로 변환


```SQL
------------------------------------------------------------------------------------
-- 003_select_function.sql
-- 1. 문자열
-- 2. 숫자    :   round / trunc ( 반올림/버림), ceil(올림) , floor (내림) , mod (나머지)
-- 3. 날짜    :   sysdate(날짜계산) (시스템날짜), add_months(몇달뒤에), next_day, last_day 마지막날
-- 4. 변환    :   to_char (날짜형식변환) , to_date 
-- 5. 조건    :   decode, case, nvl, nvl2
------------------------------------------------------------------------------------
-- 2. 숫자    :   round / trunc(반올림/버림), ceil(올림), floor(내림), mod(나머지)

select 

    round( 1234.5678 ) --1235   
,   round( 1234.5678 , 2) --1234.57
,   trunc( 1234.5678 , 2) --1234.56 무조건 버림

,   ceil(1.1) -- 2 
,   floor(4.8) -- 4
,   mod(10,3) -- 1

from dual;


------------------------------------------------------------------------------------
-- 3. 날짜    :   sysdate(날짜계산) (시스템날짜), add_months(몇달뒤에), next_day, last_day 마지막날
select  sysdate , add_months ( sysdate, 2)  , months_between(   '25-12-1'   , '24-12-1' ) -- 달차이계산
from    dual;

select 
    NEXT_DAY(SYSDATE, '월요일') --다음주 월요일 
,   LAST_DAY(SYSDATE)    --해당월의 마지막 날짜
from    dual;

select 
    NEXT_DAY(SYSDATE, 1) --다음주 월요일 
,   LAST_DAY(SYSDATE)    --해당월의 마지막 날짜
from    dual;

------------------------------------------------------------------------------------
-- 4. 변환    :   to_char (날짜형식변환) , to_date
--                날짜를      문자로                         문자를          날짜로
select  TO_CHAR( sysdate, 'yyyy-mm-dd' ) ,  TO_DATE (  '2025-10-16' , 'YYYY-MM-DD')
from dual;

--      숫자 1234를 문자열로 변환한 다음 +1 (자동변환해서 오류가 안날수 있음 자료형이 맞아야함)
select  TO_CHAR(1234)                    + 1 ,    TO_NUMBER('5678') + 1
from    dual;

select  TO_CHAR('일이삼사')               + 1 ,    TO_NUMBER('5678') + 1      -- 오류
from    dual;

select              "1234"      + 1 , 1+"1234"       --  자료형이 안맞으면 오류남.
from        dual;


------------------------------------------------------------------------------------
-- 5. 조건    :   nvl, nvl2 ( null) , decode, case ( 조건분기) 

select nvl( NULL   , '대체값')              from  dual; -- null 이면 대체값         / null  value   logic ( replacement )
select nvl(         comm     , '입력안됨.') from   emp; -- x 오류
select nvl( to_char(comm)    , '입력안됨.') from   emp; -- o 자료형을 맞춰야함.

select nvl2( NULL, 'A' , 'B' )   from dual; -- null 일때 b, 아니면 a

select nvl2( mgr,          mgr,  '--' )   from emp; -- 오류나는 이유는? 매개변수가 값, ture(null) 인경우 표시값, false(null) 인경우 표시값 을 입력해야한다.
select nvl2( mgr,  to_char(mgr),  '상위관리자 x' )   from emp; -- 해결방안 to_char로 문자열로 변환시켜 자료형을 일치시킨다.    (nvl nv2 null일 때 값 반환 / 자료형 맞추기)

select decode( deptno, 10, '부서10', 20, '부서20', 30, '부서30')
from   emp;

select case 
           when deptno=10 then '부서10' 
           when deptno=20 then '부서20' 
           when deptno=30 then '부서30' 
           else '부서x'
       end
from   emp;
----
select case deptno
           when 10 then '부서10' 
           when 20 then '부서20' 
           when 30 then '부서30' 
           else '부서x'
       end
from   emp;

------------------------------------------------------------------------------------
-- ##1. 문자열 연습문제    (45~49)
-- https://sally03915.github.io/stackventure_250825/004_oracle/oracle004_select_fn#61

--45
select EMPNO, ENAME, SAL, COMM, SAL+COMM, NVL(COMM,0), SAL+NVL(COMM,0) from emp;

--46
select EMPNO, ENAME, COMM, NVL2(COMM,'O','X'), SAL*12+NVL2(COMM,COMM,0) ANNSAL FROM EMP;

--47
select EMPNO, ENAME, JOB, SAL, 
    decode(JOB
    , 'MANAGER', SAL+(SAL*0.1)      --when then
    , 'SALESMAN', SAL+(SAL*0.05)    --when then
    , 'ANALYST' , SAL               --when then
    , (sal+(sal*0.03))  -- else
    ) UPSAL  
from emp;

--48
select EMPNO, ENAME, JOB, SAL,
        case job
            when 'MANAGER'  THEN SAL+(SAL*0.1) 
            when 'SALESMAN' THEN SAL+(SAL*0.05) 
            when 'ANALYST'  THEN SAL
            ELSE SAL+(SAL*0.03)
            END AS UPSAL
from emp;

--49
select EMPNO, ENAME, COMM,
CASE 
when COMM is NULL then '해당사항 없음' 
when COMM = 0    then '수당없음'
--when COMM > 0    then '수당 : ' || COMM
when COMM > 0    then concat( '수당 : ', COMM)
end AS COMM_TEXT
from emp;

```




## 네트워크관리사 2급

1. ip - 컴퓨터 집주소</br>
2. IPv4 - 옛날 집주소</br> 
   192.168.0.1 = > 0~255.0~255.0~255.0~255</br>
    2^8 = 256 = 0 ~ 255  1byte=8bit</br>
    8*4 = 32칸 = 42억</br>

3. IPv6 - 새로생긴 마을의 주소</br>
    128칸 ~ 거의 무한대







클래스 A : 왕국, 나라</br>
클래스 B : 도시급</br>
클래스 C : 동네</br>
클래스 D : 방송</br>
클래스 E : 연구실</br>
사설 ip 10, 172, 192</br>




ip 주소의 분류
네트워크 id + 호스트 id
인천시          703호

서브넷 마스크 = 여기서부터 마을, 여기서부터 집

NAT - 번역마법

- 마을 안에서는 사설주소만 사용가능
- 내부용 IP - 192.168.0.5 인데
밖에서 표현하는 203.25.112.1 보여줄께

> 내부용IP를 외부용으로 바꿔주는 번역기

브로드캐스트
> 마을 전체에 편지 보내기
> 애들아~ 이거봐봐

루프백 주소
나 동작잘하니?
127.0.0.1
> 자신에게 보내는 테스트편지 

사설IP VS 공인 IP

사설IP : 마을안에서만 쓰는 비공개 주소
→10.x.x.x / 172.16~31.x.x / 192.168.x.x
10,172,192

공인IP : 세상에서 쓰는 공개주소
A = 국가기관, 큰회사  - 1
B = 중간회사         - 128
C = 집, 소규모 사무실 - 192
