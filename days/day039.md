-- join(면접시 단골문제)
-- 여러테이블을 한 개의 테이블처럼 사용하는 것
-- 공토컬럼 기준으로 연결

-- 1-1. 내부조인
--      등가조인   (=)   : 매칭되는 행. where 절     emp.deptno = dept.deptno
--      비등가조인 (= X) :              sal between losal and hisal
--      자체조인         : emp e1, emp e2

-- 1-2. outer join : 매칭되지 않은 행도 포함. left, right, full outer join

-- ERD : Entity(테이블), Relationship (관계), diagram(표)
-- 특징 : Entity(테이블), Relationship (관계), Attribute(속성)


-- #1. 내부조인 (등가조인)
select *
from emp e, dept d
where e.deptno = d.deptno;  -- 14 * 4 = 56


select *
from emp e join dept d on( e.deptno = d.deptno);

select *
from emp e join dept d using (deptno );

select *
from emp e natural join dept d;


--# 2.  외부조인 ( 매칭되지 X )

SELECT * FROM DEPT;     -- DEPTNO 10, 20, 30, 40 ( 40 , OPERATIONS , BOSTON)
SELECT * FROM EMP;      -- DEPTNO 10, 20, 30

-- 1. (+) ORACLE에서만        -- (+) 없는 데이터 NULL 보충해줄께. (+) 안붙은 테이블의 데이터를 보장

SELECT E.ENAME , DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO(+); -- 14 EMP 테이블 보장 , DEPT 에서 모자라는 데이터 없는 데이터 NULL 채울께

SELECT E.ENAME , DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO; -- 15 DEPT 테이블 보장, EMP에서 모자라는 데이터 없는 데이터 NULL 채울께

-- 2. LEFT JOIN , RIGHT JOIN (ANSI조인 = 표준)
SELECT ENAME , DNAME

FROM   EMP E INNER JOIN DEPT D ON ( E.DEPTNO = D.DEPTNO); -- INNER JOIN, 내부조인, 겹치는 애들만 OUTER JOIN 아님 !!! INNER JOIN , 내부조인, 겹치는 애들만


SELECT ENAME , DNAME
FROM   EMP E RIGHT OUTER JOIN DEPT D 
ON    ( E.DEPTNO = D.DEPTNO); -- RIGHT 쪽에 있는 테이블 보장 (NULL, OPERATIONS)

SELECT ENAME , DNAME
FROM   EMP E LEFT OUTER JOIN DEPT D 
ON    ( E.DEPTNO = D.DEPTNO); -- LEFT 쪽에 있는 테이블 보장 (NULL, OPERATIONS)

-- 3. OUTER JOIN ( 두테이블에 있는 모든 데이터를 결합)
SELECT ENAME , DNAME
FROM    EMP E   FULL OUTER JOIN DEPT D
ON     E.DEPTNO = D.DEPTNO;

-- 각각의 테이블 보장

-- 비표준 = , (+)
-- 표준 NATURAL JOIN, JOIN ON, JOIN USING , LEFT JOIN, RIGHT JOIN , FULL JOIN






-- emp e, dept d 별명 / empno, ename, deptno, dname 관계를 맺어서 한테이블에 조인시키는것
select empno, ename, e.deptno, dname
from emp e, dept d
where e.deptno = d.deptno;

select empno, ename, e.deptno, dname
from emp e join dept d on ( e.deptno = d.deptno);

select empno, ename, deptno, dname
from emp e join dept d  using ( deptno);



--Q001
--EMP, DEPT 테이블을 이용하여 FROM 절에 여러 테이블을 선언해해 다음과 같이 출력하시오
--모든 행과 열이 곱해진 값 (위험한 코드 만개넘어가면 서버 멈춤)

select * 
from emp, dept
order by empno;

--Q002
--EMP, DEPT 테이블을 이용하여
--EMP의 DEPTNO와 DEPT테이블의 DEPTNO가 같은 데이터를 다음과 같이 출력하시오

select * 
from emp e, dept d
where e.deptno = d.deptno -- emp.deptno = dept.deptno
order by empno;

select *
from emp join dept on(emp.deptno = dept.deptno)
order by empno;

select *
from emp join dept using(deptno)
order by empno;

select *
from emp natural join dept
order by empno;


--Q003
--EMP, DEPT 테이블을 이용하여
--FROM 절에 EMP 테이블의 별칭은 E, DEPT 테이블의 별칭은 D로 다음과 같이 출력하시오

select * 
from emp e, dept d
where e.deptno = d.deptno
order by empno;

select *
from emp join dept 
on (emp.deptno = dept.deptno)
order by empno;

select *
from emp join dept
using (deptno)  -- 똑같은 필드를 찾는다
order by empno;

select *
from emp e natural join dept d
order by empno;

--Q004
--EMP, DEPT 테이블을 이용하여
--두테이블에 부서번호가 같은 열의 이름이 포함되었을때 다음과 같이 출력하시오 (에러발생)
-- join 사용시 select에 어떤 테이블의 소유인지 테이블.열이름(테이블명 별칭가능)
select empno, ename, deptno, dname, loc
from emp e, dept d
where e.deptno = d.deptno
order by empno;


--Q005
--EMP, DEPT 테이블을 이용하여
--열 이름에 각각의 테이블 이름도 함께 명시시 다음과 같이 출력하시오 ( 위의 문제 해결 )
-- 겹치는 부분만 D. E. , 모든필드에 E
select e.empno, e.ename, d.deptno, d.dname, d.loc
--select empno, ename, d.deptno, dname, loc
from emp e, dept d
where e.deptno = d.deptno
order by dname ;



--Q006 = , join on, join using , natural join
--EMP, DEPT 테이블을 이용하여
--급여가 3000이상인 사원의 사원번호, 이름, 급여, 근무부서를 다음과 같이 출력하시오
select e.empno, e.ename, sal, d.deptno, d.dname, d.loc
from emp e, dept d
where e.deptno = d.deptno and sal >= 3000
order by dname ;

select empno, ename, sal, d.deptno, dname, loc
from emp e join dept d on (e.deptno = d.deptno)
where  sal >= 3000
order by dname ;

select *
from emp e join dept d using (deptno)
where  sal >= 3000
order by dname ;

select empno, ename, sal, deptno, dname, loc
from emp e natural join dept d
where  sal >= 3000
order by dname ;


--Q007
--EMP, SALGRADE 테이블을 이용하여
--유저 정보, 급여등급 , 그 등급의 최소급여와 최대급여를 다음과 같이 출력하시오

select empno, ename, job, mgr, hiredate,  sal, comm, deptno, grade, losal, hisal 
from emp e, SALGRADE s
where sal between losal and hisal
order by sal;

select *  -- 확인
from emp e, SALGRADE s
where e.sal >= losal and e.sal <= hisal;

select *
from emp e join salgrade s on (e.sal >= losal and e.sal <= hisal);

--select 
--from emp e join salgrade s using (겹치는 필드가 안보임 x- 서브쿼리로 가능 );

select *
from emp e, salgrade s
where e.sal between losal and hisal;

select *
from emp e join salgrade s on (e.sal >= losal and e.sal <= hisal);

--select *
--from emp e join SALGRADE s using (겹치는 필드가 안보임 x-  서브쿼리로 가능);,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,





--Q008
--EMP테이블을 2번 이용하여
--사원정보(EMPNO, ENAME, MGR) 와 직속상관(EMPNO, ENAME)의 사원번호를 다음과 같이 출력하시오

select e1.empno , e1.ename, e1.mgr , e2.empno MGR_EMPNO, e2.ename EMG_ENAME
from emp e1 , emp e2
where e1.mgr = e2.empno
order by e2.empno; -- E1.MGR ASC;


select e1.empno , e1.ename, e1.mgr , e2.empno MGR_EMPNO, e2.ename EMG_ENAME
from emp e1 join emp e2 on (e1.mgr = e2.empno)
order by e2.empno; -- E1.MGR ASC;

--select empno , e1.ename, mgr , empno MGR_EMPNO, e2.ename EMG_ENAME
--from emp e1 join emp e2 USING  (같은필드 X) --(MGR, EMPNO) 동작은 하나 값이 틀림
--order by empno; -- E1.MGR ASC;



-- USING X , natural X

--Q009
--EMP테이블을 2번 이용하여
--사원정보(EMPNO, ENAME, MGR) 와 직속상관(EMPNO, ENAME)의 사원번호를 다음과 같이 출력하시오
--직속상관이 없는 사원의 정보도 출력하시오


SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+)
ORDER BY E1.EMPNO; -- (+) null 채워줄꼐

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1 left join  EMP E2 on (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO; -- 왼쪽 테이블의 데이터가 무조건 다나오게

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E2 right join  EMP E1 on (E1.MGR = E2.EMPNO)
ORDER BY E1.EMPNO; -- 오른쪽테이블의 데이터가 무조건 다나오게

--Q010
--(+)의 위치를 바꿔서 출력해보고 다음이 의미하는 바를 적으시오

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO
ORDER BY E1.EMPNO; -- (+) null 채워줄게, 매니저들의 번호와 이름은 있으나, 관리하는 사원이 없음

-- 부하 직원이 없는 매니저도 을 출력 NULL 채워서

--Q011 표준문법 (NATURAL JOIN)
--EMP , DEPT 테이블 이용하여
--EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM를 다음과 같이 출력하시오
--NATURAL JOIN
--알아서 두 테이블의 이름과 자료형이 같은 열을 찾은 후
--그 열을 기준으로 등가조인을 해주는 방식
SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME, LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO, ENAME;


--Q012 표준문법 (JOIN USING)
--EMP , DEPT 테이블 이용하여
--EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM를 다음과 같이 출력하시오
--JOIN USING
--USING에 조인기준열 명시
--그 열을 기준으로 등가조인을 해주는 방식

SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D USING (DEPTNO)
WHERE SAL >= 3000 --
ORDER BY DEPTNO, ENAME;

SELECT EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO, DNAME, LOC
FROM EMP E JOIN DEPT D on (e.DEPTNO = d.deptno)
WHERE SAL >= 3000 --
ORDER BY DEPTNO, empno;


--Q013 표준문법 (JOIN ON)
--EMP , DEPT 테이블 이용하여 EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM를 다음과 같이 출력하시오
--
--
--JOIN ON
--ON에 조인기준열 명시
--그 열을 기준으로 등가조인을 해주는 방식

select empno, ename, job, mgr, hiredate, sal, comm, e.dept


SELECT E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL, E.COMM, E.DEPTNO, D.DNAME, D.LOC -- 명시를 해줘야하는듯 
FROM EMP E JOIN DEPT D ON (E.DEPTNO = D.DEPTNO)
ORDER BY DEPTNO, ENAME;

--Q014 표준문법 (LEFT OUTER JOIN )
--EMP , DEPT 테이블 이용하여 다음과 같이 출력하시오
--LEFT OUTER JOIN
--왼쪽 외부조인을 기준으로 NULL보장

select e1.empno, e1.ename, e1.mgr, e2.empno MGR_EMPNO , e2.ename MGR_ENAME
from emp e1 LEFT OUTER JOIN emp e2 on (e1.mgr = e2.empno)
order by e1.empno;

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO MGR_EMPNO , E2.ENAME MGR_NAME
FROM EMP E1 LEFT OUTER JOIN EMP E2
ON (E1.MGR = E2.EMPNO)
order BY E1.EMPNO;


--Q015 표준문법 (RIGHT OUTER JOIN )
--EMP , DEPT 테이블 이용하여 다음과 같이 출력하시오
--RIGHT OUTER JOIN- 오른른쪽 외부조인을 기준으로 NULL보장

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO MGR_EMPNO , E2.ENAME MGR_NAME
FROM EMP E1 RIGHT OUTER JOIN EMP E2
ON (E1.MGR = E2.EMPNO)
order BY E1.EMPNO;

select e1.empno, e1.ename, e1.mgr, e2.empno MGR_EMPNO , e2.ename MGR_ENAME
from emp e2 RIGHT OUTER JOIN emp e1 on (e1.mgr = e2.empno)
order by e1.empno;



--Q016 표준문법 (FULL OUTER JOIN )
--EMP , DEPT 테이블 이용하여 다음과 같이 출력하시오
--FULL OUTER JOIN - 양쪽모두두 외부조인을 기준으로 NULL보장

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO MGR_EMPNO , E2.ENAME MGR_NAME
FROM EMP E1 full OUTER JOIN EMP E2
ON (E1.MGR = E2.EMPNO)
order BY E1.EMPNO;

select e1.empno, e1.ename, e1.mgr, e2.empno MGR_EMPNO , e2.ename MGR_ENAME
from emp e2 FULL OUTER JOIN emp e1 on (e1.mgr = e2.empno)
order by e1.empno;


--EX001
--EMP, DEPT 테이블을 이용하여
--SQL-99 이전 방식다음 , SQL-99방식 두가지 방식으로 다음과 같이 출력하시오.
--급여(SAL)이 2000초과인 사원들의 부서정보, 사원정보를 출력하시오.


SELECT D.DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO AND SAL > 2000;




SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM DEPT D join EMP E on (D.DEPTNO = E.DEPTNO)and sal >2000
ORDER BY DEPTNO ;

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.SAL
FROM DEPT D , EMP E 
where D.DEPTNO(+) = E.DEPTNO and sal >2000
ORDER BY DEPTNO, ENAME DESC;


--EX002
--EMP, DEPT 테이블을 이용하여
--SQL-99 이전 방식다음 , SQL-99방식 두가지 방식으로 다음과 같이 출력하시오.
--각 부서별 평균급여, 최대급여, 사원수를 출력하시오.

SELECT D.DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM DEPT D JOIN EMP E ON (D.DEPTNO = E.DEPTNO)
WHERE SAL > 2000;

SELECT DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM DEPT D JOIN EMP E USING ( DEPTNO)
WHERE SAL > 2000;

SELECT DEPTNO, DNAME, EMPNO, ENAME, SAL
FROM DEPT D NATURAL JOIN EMP 
WHERE SAL > 2000;


SELECT   D.DEPTNO, DNAME, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*) CNT
FROM     DEPT D , EMP E
WHERE    D.DEPTNO = E.DEPTNO
GROUP BY D.DEPTNO , DNAME;



SELECT D.DEPTNO, DNAME, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*) CNT
FROM EMP E, DEPT D
where D.DEPTNO(+) = E.DEPTNO
GROUP BY GROUPING SETS(D.DEPTNO), DNAME;


SELECT E.DEPTNO, D.DNAME, TRUNC(AVG(SAL)), MAX(SAL), MIN(SAL), COUNT(*) CNT
FROM EMP E LEFT OUTER JOIN  DEPT D
ON ( D.DEPTNO = E.DEPTNO )
GROUP BY E.DEPTNO, D.DNAME;

--EX003
--EMP, DEPT 테이블을 이용하여
--SQL-99 이전 방식다음 , SQL-99방식 두가지 방식으로 다음과 같이 출력하시오.
--모든 부서정보와 사원정보를 부서번호, 사원이름 순으로 정렬해 출력하시오.

SELECT D.DEPTNO, D.DNAME, EMPNO, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO
ORDER BY DEPTNO;


SELECT D.DEPTNO, D.DNAME, EMPNO, ENAME, JOB, SAL
FROM EMP E RIGHT OUTER JOIN  DEPT D
ON (D.DEPTNO = E.DEPTNO) 
ORDER BY DEPTNO;

SELECT D.DEPTNO, D.DNAME, EMPNO, ENAME, JOB, SAL
FROM  DEPT D LEFT OUTER JOIN  EMP E
ON (D.DEPTNO = E.DEPTNO) 
ORDER BY DEPTNO;


SELECT D.DEPTNO, D.DNAME, EMPNO, ENAME, JOB, SAL
FROM EMP E, DEPT D
WHERE D.DEPTNO(+) = E.DEPTNO
ORDER BY D.DEPTNO,E.ENAME;


--
--EX004
--EMP, DEPT 테이블을 이용하여
--SQL-99 이전 방식다음 , SQL-99방식 두가지 방식으로 다음과 같이 출력하시오.
--모든 부서정보와 사원정보, 급여등급정보, 각사원의 직속상관의 정보를
--부서번호, 사원번호 순서로 정렬해 출력하시오.

SELECT D.DEPTNO, D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO, MIN(E.SAL) LOSAL, MAX(E.SAL) HISAL, DECODE(
,CASE 
WHEN E.SAL >= 1000 THEN '1' 
WHEN E.SAL >= 2000 THEN '2' 
WHEN E.SAL >= 3000 THEN '3' 
WHEN E.SAL >= 4000 THEN '4' 
ELSE 5 
END 
AS GRADE 
--, E.EMPNO MGR_EMPNO , E.ENAME MGR_ENAME
FROM EMP E, DEPT D
WHERE D.DEPTNO = E.DEPTNO
GROUP BY GROUPING SETS(D.DEPTNO), D.DNAME, E.EMPNO, E.ENAME, E.MGR, E.SAL, E.DEPTNO --, E.EMPNO, E.ENAME
ORDER BY D.DEPTNO;


SELECT  D.DEPTNO, DNAME, E1.EMPNO, E1.ENAME, E1.MGR, E1.SAL, E1.DEPTNO, LOSAL, HISAL, GRADE, E2.EMPNO MGR_EMPNO , E2.ENAME MGR_ENAME 
FROM    EMP E1, DEPT D, SALGRADE S, EMP E2
WHERE   E1.DEPTNO(+) = D.DEPTNO AND E1.SAL BETWEEN LOSAL(+) AND HISAL(+) AND E1.MGR = E2.EMPNO(+)
ORDER BY D.DEPTNO;











--Q009
--EMP테이블을 2번 이용하여
--사원정보(EMPNO, ENAME, MGR) 와 직속상관(EMPNO, ENAME)의 사원번호를 다음과 같이 출력하시오
--직속상관이 없는 사원의 정보도 출력하시오


SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO;

--Q010
--(+)의 위치를 바꿔서 출력해보고 다음이 의미하는 바를 적으시오

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR(+) = E2.EMPNO;
-- EMP E1에 NULL 을 채워서 E2데이터를 보장한다.

SELECT E1.EMPNO, E1.ENAME, E1.MGR, E2.EMPNO, E2.ENAME
FROM EMP E1, EMP E2
WHERE E1.MGR = E2.EMPNO(+);
-- EMP E2에 NULL 을 채워서 E1데이터를 보장한다.



-- 1
select * from emp;

-- 2. 집계함수 - sum, count, max, min, avg
select sum(sal) from emp;   -- 1개

-- 3. 부서의  직업별 급여의 평균  group by>  deptno , job
select deptno , job ,    avg(sal) from emp  group by deptno , job ; 

-- 4. where  vs having - [급여의 평균]에서 2000이상
select   deptno , job ,    avg(sal)  -- 5.
from     emp              -- 1
where    sal>=1500        -- 2 전체데이터에서 필터 
group by deptno , job     -- 3 [부서의  직업별], 급여의 평균
having   avg(sal) > 2000; -- 4. 3번에서 나온  급여의 평균 으로 having


-- 5. rollup ,cube, grouping sets / pivot, unpivot
--       [부서의  직업별] , 명수,     급여의 평균
--  rollup :  10부서의 직업 급여의 평균, 20부서의  급여의 평균 , 30부서의  급여의 평균 = 전체 총계   작은>큰거
select      deptno, job ,  count(*) ,  round( avg(sal) , 1)
from        emp
group by    rollup(deptno , job) ; 

--  cube :  deptno + job전체총계 , job 총계 , deptno 총계 , deptno + job각각의 세부내용   큰거에서 > 작은걸로
select      deptno, job ,  count(*) ,  round( avg(sal) , 1)
from        emp
group by    cube(deptno , job) ; 

-- grouping 뭘로묶였는지 확인 - 해당컬럼이 실제로 그룹화되었니?   0 그룹화에 포함됨 / 1 그룹화에 포함이 되지 않음.
select      deptno, job ,  grouping(deptno) , grouping(job) 
from        emp    -- 1
group by    cube(deptno , job) ; -- 2         deptno + job, job, deptno , 둘다세부

--  pivot  행데이터를 열로
select   *
from     (   select  컬럼1, 컬럼2 , 집계대상컬럼 from 테이블명          )   -- 원본데이터 : pivot을 적용할 대상
pivot    (   집계함수(집계대상) for  컬럼기준 in (값1, 값2, 값3 ,,,)    );  -- 집계함수   : 어떤컬럼기준으로 만들 것인지 지정

-- 1) job별 부서 10,20,30의 최대급여 
select  * 
from     (     select  deptno, job, sal from emp  )
pivot    (     max(sal)  for deptno in(10,20,30)  );  

-- 2) 직무별 부서  사원 수   - job별 부서 10,20,30의 사원 수
select    *
from     (  select  job, deptno , empno  from emp   )    
pivot    (  count(empno)   for  deptno  in (10,20,30)    );

-- 3) 부서별 직무 평균 급여   
select    * 
from    ( select deptno, job , sal  from emp  )
pivot   ( avg(sal)  for  job in ( 'CLERK'  , 'MANAGER', 'SALESMAN' )   );

-- unpivot  열데이터를 행으로 
-- decode(job,'CLERK' , sal)  JOB필드에서   CLERK 인경우만 SAL 반환, 아니면 NULL
select  *
from    (
    select  deptno, max(  decode(job,'CLERK' , sal)    ) CLERK 
                  , max(  decode(job,'MANAGER' , sal)  ) MANAGER    --#3
    from emp   --#1
    group by deptno  --#2
)  -- 원본데이터 : unpivot을 적용할대상( 열형태로 집계된 데이터)
unpivot (
    SAL FOR  JOB  IN (CLERK ,MANAGER  )
); --  unpivot : 열을 행으로 변환, 기준컬럼 열이름이었던것을 행 값으로 변환
-- 풀이1) DEPTNO , CLERK(열) , MANAGER(열)
-- 풀이2) DEPTNO ,    JOB ,  SAL
--                   CLERK
--                   MANAGER

--1)             ↓(열)       ↓(열)
    DEPTNO      CLERK    MANAGER
---------- ---------- ----------
        30        950       2850
        20       1100       2975
        10       1300       2450


-- 2) unpivot
    DEPTNO JOB                   SAL
---------- -------------- ----------
        30 CLERK                 950   → (행)
        30 MANAGER              2850   →
        20 CLERK                1100   →
        20 MANAGER              2975
        10 CLERK                1300
        10 MANAGER              2450
-- 

-- #### https://sally03915.github.io/stackventure_250825/004_oracle/oracle005_select_group#38
-- Q25~39

--Q025
--EMP 테이블에서 ROLLUP 함수를 이용하여  
--부서별(큰그룹) 직책(소그룹)의  
--사원수, 가장 높은 급여, 급여의 합, 평균급여를 출력하시오.

select     deptno, job,  count(*) , max(sal), sum(sal), avg(sal)  
from       emp   
group by   rollup( deptno, job );   

--Q026
--EMP 테이블에서 CUBE(DEPTNO, JOB) 함수를 이용하여
--부서별(큰그룹) 직책(소그룹)의
--사원수, 가장 높은 급여, 급여의 합, 평균급여를 출력하시오.( deptno + job(총), job(중간분류), deptno(중간분류) deptno+job(세부사항) )

select     deptno, job,  count(*) , max(sal), sum(sal), avg(sal)  
from       emp   
group by   cube( deptno, job );


--Q027
--EMP 테이블에서
--DEPTNO를 먼저 그룹화한후 ROLLUP 함수에 JOB을 지정하여
--사원수를 출력하시오.
select deptno, job, count(*)
from   emp
group by deptno, rollup(  job  );



--Q028
--EMP 테이블에서
--JOB을 먼저 그룹화한후 ROLLUP 함수에 DEPTNO을 지정하여
--사원수를 출력하시오.
select deptno, job, count(*)
from   emp  -- 1 
group by job, rollup(  deptno  );



--Q029
--EMP 테이블에서
--GROUPING SETS (DEPTNO, JOB) 함수를 사용하여
--열별 그룹으로 묶어 결과로 출력하시오.  ## 풀기
select deptno, job, count(*)
from   emp   
group by GROUPING SETS (DEPTNO, JOB);

## 풀이)
-- 다중그룹을 한번에 지정
1) group by DEPTNO      -- job은  null로
2) group by JOB         -- deptno null로

## RESULT)
    DEPTNO JOB                  COUNT(*)
---------- ------------------ ----------
           CLERK                       4
           SALESMAN                    4
           PRESIDENT                   1
           MANAGER                     3
           ANALYST                     2
        30                             6
        20                             5
        10                             3




--Q030
--EMP 테이블에서 DEPTNO JOB열의 그룹화결과를 GROUPING 함수로 출력하시오 ( 기준점적용 : 0 )
SELECT     DEPTNO, JOB, COUNT(*), MAX(SAL),  SUM(SAL), AVG(SAL) , GROUPING(DEPTNO), GROUPING(JOB) 
FROM       EMP
GROUP BY   CUBE(DEPTNO, JOB);




--Q031
--DECODE문으로 GROUPING 함수를 적용하여 결과를 표기하시오오
--  GROUPING(DEPTNO) 가 1이라면 적용안되었다라는의미    ALL_DEPT  
SELECT   DECODE( GROUPING(DEPTNO),1  , 'ALL_DEPT' , DEPTNO    ) AS DEPTNO 
        ,DECODE( GROUPING(JOB)   ,1  , 'ALL_JOB'  , JOB       ) AS JOB
        ,COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
FROM    EMP
GROUP   BY  CUBE(DEPTNO, JOB)
ORDER   BY   DEPTNO, JOB;


--Q032
--DEPTNO, JOB을 함께 명시한 GROUPING_ID 함수를 사용하시오.  ##안내   GROUPING_ID : 집계수준(몇번집계)
SELECT    DEPTNO, JOB , COUNT(*), SUM(SAL), GROUPING(DEPTNO), GROUPING(JOB) , GROUPING_ID(DEPTNO, JOB)
FROM      EMP
GROUP BY  CUBE(DEPTNO, JOB)
ORDER BY  DEPTNO, JOB;

1) DEPTNO (O), JOB(0)               GROUPING_ID(0)  정상조합                   0*2^1 + 0*2^0 = 0
2) DEPTNO (O), JOB(1: NULL)         GROUPING_ID(1)  DEPNO 실제값, JOB NULL     0*2^1 + 1*2^0 = 1
3) DEPTNO (1: NULL), JOB(0)         GROUPING_ID(2)  JOB 실제값  , DEPTNO NULL  1*2^1 + 0*2^0 = 2
3) DEPTNO (1: NULL), JOB(1: NULL)   GROUPING_ID(3)  전체집계   둘다 NULL        1*2^1 + 1*2^0 = 3    2^0은 1      



--Q033
--EMP 테이블에서 GROUP BY로 그룹화하여 부서번호와 사원이름을 출력하시오.
select    DEPTNO, ENAME
from      emp
group by  DEPTNO, ENAME;


--Q034
--EMP 테이블에서 부서별 사원이름을 나란히 나열하여 출력하시오.
--LISTAGG( 나열할 열, 구분자)
--WITHIN GROUP(ORDER BY 나열할 열의 정렬기준)  ##안내
--        그룹핑    이름들을 가로방향으로 나열-                    SAL 내림차순
SELECT    DEPTNO,   LISTAGG(  ENAME, ', ' )  WITHIN  GROUP(   ORDER BY SAL DESC )  ENAMES
FROM      EMP
GROUP BY  DEPTNO ;

--Q035
--EMP 테이블에서 부서, 직책별 그룹화하여 최고급여데이터를 출력하시오
SELECT     DEPTNO, JOB , MAX(SAL)
FROM       EMP
GROUP BY   DEPTNO, JOB 
ORDER BY   DEPTNO, JOB ;


--Q036  (행-> 열)
--EMP 테이블에서 PIVOT함수를 사용하여 직책별* 부서별 최고급여를 2차원 표 형태로 출력하시오
SELECT *
FROM  (  SELECT DEPTNO, JOB , SAL FROM EMP   )  
PIVOT (  MAX(SAL)  FOR DEPTNO IN (10,20,30) );


--Q037
--EMP 테이블에서 PIVOT함수를 사용하여 부서별*직책책별 최고급여를 2차원 표 형태로 출력하시오
SELECT *
FROM  (   SELECT  DEPTNO, JOB, SAL FROM EMP   )
PIVOT (   MAX(SAL)  FOR  JOB  IN( 'PRESIDENT' , 'MANAGER',  'ANALYST' , 'CLERK', 'SALESMAN'  )  );


--Q038
--EMP 테이블에서 DECODE문을 활용하여 PIVOT 함수와 같은 결과를 출력하시오
SELECT   DEPTNO  
         , MAX(  DECODE(  JOB , 'CLERK'        , SAL )  )   CLERK
         , MAX(  DECODE(  JOB , 'SALESMAN'     , SAL )  )   SALESMAN
         , MAX(  DECODE(  JOB , 'PRESIDENT'    , SAL )  )   PRESIDENT
         , MAX(  DECODE(  JOB , 'MANAGER'      , SAL )  )   MANAGER
         , MAX(  DECODE(  JOB , 'ANALYST'      , SAL )  )   ANALYST
FROM     EMP
GROUP BY DEPTNO;



--Q039
--EMP 테이블에서 UNPIVOT 활용하여 열로 구분된 그룹을 행으로 출력하시오
SELECT *
FROM (
    SELECT   DEPTNO  
             , MAX(  DECODE(  JOB , 'CLERK'        , SAL )  )   CLERK
             , MAX(  DECODE(  JOB , 'SALESMAN'     , SAL )  )   SALESMAN
             , MAX(  DECODE(  JOB , 'PRESIDENT'    , SAL )  )   PRESIDENT
             , MAX(  DECODE(  JOB , 'MANAGER'      , SAL )  )   MANAGER
             , MAX(  DECODE(  JOB , 'ANALYST'      , SAL )  )   ANALYST
    FROM     EMP
    GROUP BY DEPTNO
)
UNPIVOT (
     SAL     FOR JOB IN(CLERK ,SALESMAN , PRESIDENT , MANAGER  , ANALYST)
)
ORDER BY DEPTNO, SAL;




--https://sally03915.github.io/stackventure_250825/004_oracle/oracle005_select_group#58
-- Ex001~Ex005

--Ex001
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--부서번호(DEPTNO) , 평균급여(AVG_SAL) , 최고급여(MAX_SAL) , 최저급여(MIN_SAL) , 사원수(CNT) 를 조회하시오
--평균급여를 출력시 소수점을 제외하고 각 부서번호별로 출력하시오.


--Ex002
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--같은직책(JOB)에 종사하는 사원이 3명 이상인 직책과 인원수를 출력하시오.


--Ex003
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--사원들의 입사년도(HIRE_YEAR)를 기준으로 부서별 몇명이 입사했는지 조회하시오.

--Ex004
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--추가수당(COMM)을 받는 사원수와 받지않는 사원수를 조회하시오.

--Ex005
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--각 부서의 입사연도별 사원수, 최고급여, 급여합, 평균급여를 출력하고
--각 부서별 소계와 총계를 출력하시오. (ROLLUP)

--
select * from emp;

-- 집계 sum , max , min , avg , count

select sum(sal)  from emp;   --  급여의 합계
select sum(comm) from emp;   --  null 값이 있어도 계산가능

--     14줄  1줄 
--select sal, sum(sal), max(sal), min(sal), avg(sal), count(sal) from emp; -- error
select sum(sal) 합 , max(sal) 최대, min(sal) 최소 , round(avg(sal) , 2) 평균, count(sal) 갯수 from emp; -- error

-- 3. group by 
--select    --5
--from      --1
--where     --2  (전체 필터링)
--group by    --3 그룹핑
--having      --4 그룹핑안에서 조건 (그룹핑 후 필터링)
--order by;   --6
-- 부서별 급여의 합
select  deptno   , sum(sal) 
from    emp
group by deptno;


-- 4. having (합계를 구했을때 9000이상인 그룹)
select      deptno, sum(sal) , count(*)
from        emp
group by    deptno
having      sum(sal) >= 9000;


--####

--1
select sum(sal)
from emp;

--2 error 이유 14, 1  그룹핑 대상의 갯수가 안맞다. 
--select ename, sum(sal) from emp;
--select ename, sum(sal) from emp group by ename;
--select        sum(sal) from emp;

--ORA-00937: not a single-group group function

--https://docs.oracle.com/error-help/db/ora-00937/00937. 00000 -  "not a single-group group function"
--*Cause:    A SELECT list cannot include both a group function,
--           such as AVG, COUNT, MAX, MIN, SUM, STDDEV, or VARIANCE, and an
--           individual column expression, unless the individual column
--           expression was included in a GROUP BY clause.
--*Action:   Drop either the group function or the individual
--           column expression from the SELECT list or add a GROUP BY
--           clause that includes all individual column expressions listed.
--40행, 8열에서 오류 발생
-- 해결방안 group by를 넣던가

select ENAME , sum(sal)
from emp;

-- 각각의 행갯수가 다르다.

--3

select sum(comm) -- 1400 + 300 + 500 , null 미포함
from emp;

select sal+comm from emp;   -- null 포함

--4 EMP 테이블에서 sum (distinct, all) 함수를 이용하여 급여 합계를 출력하시오 -- 중복 안빼고 다처리
slect * from emp;

select sum(distinct sal), sum(all sal), SUM(SAL)
from emp;

--5

select count(*)
from emp;

--6

select count(*)
from emp
--group by deptno
--having deptno = 30;
where deptno =30;

--7


select count (distinct sal), count(all sal), count(sal)
from emp;

--8

select count(comm)
from emp;

--9 



select count(comm)      --3
from emp                --1
where comm is not null; --2


--10

select max(sal)
from emp
--group by deptno
--having deptno = 10;
where deptno = 10;

--1) select *        from emp    where deptno = 10;
--2) select max(sal) from emp where deptno = 10;



--11

select min(sal)     --3
from emp            --1
--group by deptno
--having deptno = 10; --2
where deptno = 10; --2

--12 ?

select max(hiredate)
from emp
--group by deptno
--having deptno = 20;
where deptno = 20;


--13

select min(hiredate)
from emp
group by deptno
having deptno = 20;

--select *
--from emp
--where deptno = 20;


--14

select round (avg(sal) ,2)
from emp
group by deptno
having deptno = 30;

--15

select avg(distinct sal)
from emp
group by deptno
having deptno = 30;

--16

select avg(sal), deptno
from emp 
group by deptno
having deptno = 10
union all
select avg(sal), deptno
from emp
group by deptno
having deptno = 20
union all
select avg(sal), deptno
from emp
group by deptno
having deptno = 30;

select avg(sal), '10' as deptno
from emp 
where = 10
union all
select avg(sal), '20' as deptno
from emp
where deptno = 20
union all
select avg(sal), '30' as deptno
from emp
where deptno = 30;


--17

select   deptno, avg(sal)
from     emp
group by deptno;

--18 Q018 EMP 테이블에서 부서번호(DEPTNO) 및 직책별(JOB) 평균급여(SAL)로 정렬한 후 출력하시오.

select  deptno, job, avg(sal)
from    emp
group by deptno, job -- 집계 함수 ( avg, sal, min, max, count) 빼고 다 그룹핑
order by deptno asc;

-- Q019 EMP 테이블에서 GROUP BY절에 없는 열을 SELECT절에 포함하면 에러가 난다. 그이유를 적으시오.
-- 기준을 그룹 바이로 잡고 조건을 만들기 때문에?
select ename, deptno, avg(sal)
    from emp
group by depno; -- ename, deptno,

-- 20 Q020 EMP 테이블에서 GROUP BY 와 HAVING 절을이용하여 각부서의 
-- 직책별 평균급여를 구하되 그 평균급여가 2000이상인 그룹만 출력하시오.

select deptno, job, avg(sal)
from   emp
group by sal, deptno, job
having avg(sal) >= 2000
order by deptno asc, job asc;

--21 Q021 다음 코드가 오류나는 이유를 적으시오

--그룹바이 조건에 sal이 없기 때문에?

--22 Q022 WHERE 절을 사용하지 않고 HAVING절만 사용한 경우

select deptno , job, avg(sal)
from emp
group by deptno, job, sal
having avg(sal)>=2000
order by deptno asc;

--23 Q023 WHERE절과 HAVING절을 모두 사용한경우
select deptno , job, avg(sal)   -- 5
from emp    -- 1    14줄
--where avg(sal) > 2000 -- 2 300이하인 애들
group by deptno, job, -- 3 deptno , hob 그룹의 평균
having avg(sal)>=2000 -- 4
order by avg(sal) asc; -- 6

--select deptno , job, avg(sal)
--from emp
--where sal < 5000
--group by deptno, job, sal
--Having avg(sal) > 2000;



--Q024 EMP 테이블에서 부서별(큰그룹) 직책(소그룹)의 사원수, 가장 높은 급여, 급여의 합, 평균급여를 출력하시오.
select deptno, job, count(job), max(sal), sum(sal), avg(sal)
from emp
group by deptno, job
order by deptno asc ;


--Q025 EMP 테이블에서 ROLLUP 함수를 이용하여
--부서별(큰그룹) 직책(소그룹)의
--사원수, 가장 높은 급여, 급여의 합, 평균급여를 출력하시오.

select deptno, job, count(*), max(sal), sum(sal), avg(sal)
from emp
group by rollup(deptno, job);



--Q026
--EMP 테이블에서 CUBE(DEPTNO, JOB) 함수를 이용하여
--부서별(큰그룹) 직책(소그룹)의
--사원수, 가장 높은 급여, 급여의 합, 평균급여를 출력하시오.

select deptno, job, count(*), max(sal), sum(sal), avg(sal)
from emp
group by cube(deptno, job)
order by deptno, job;

--Q027
--EMP 테이블에서
--DEPTNO를 먼저 그룹화한후 ROLLUP 함수에 JOB을 지정하여
--사원수를 출력하시오.

select deptno, job, count(*)
from emp
group by deptno, rollup(job);

--Q028
--EMP 테이블에서
--JOB을 먼저 그룹화한후 ROLLUP 함수에 DEPTNO을 지정하여
--사원수를 출력하시오.

select deptno, job, count(*)
from emp
group by job, rollup(deptno);

--Q029
--EMP 테이블에서         
--GROUPING SETS (DEPTNO, JOB) 함수를 사용하여
--열별 그룹으로 묶어어 결과로 출력하시오.

select deptno, job, count(*)
from emp
group by grouping sets(deptno, job);

--Q030
--EMP 테이블에서 DEPTNO JOB열의 그룹화결과를 GROUPING 함수로 출력하시오.

select deptno, job, count(*), max(sal), sum(sal), avg(sal), grouping(deptno), grouping(job)
from emp
group by rollup (deptno, job);


--Q031
--DECODE문으로 GROUPING 함수를 적용하여 결과를 표기하시오

select decode(grouping(deptno), 1 , 'ALL_DEPT', deptno ) AS DEPTNO ,
       decode(grouping(job), 1 , 'ALL_JOB', job ) AS job , count(*), max(sal), sum(sal), avg(sal)
from emp
group by rollup (job), rollup (deptno)
order by deptno, job asc;


--Q032
--DEPTNO, JOB을 함께 명시한 GROUPING_ID 함수를 사용하시오.

select deptno, job, count(*), sum(sal), grouping(deptno), grouping(), grouping(deptno)
from emp;

--Ex001
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--부서번호(DEPTNO) , 평균급여(AVG_SAL) , 최고급여(MAX_SAL) , 최저급여(MIN_SAL) , 사원수(CNT) 를 조회하시오
--평균급여를 출력시 소수점을 제외하고 각 부서번호별로 출력하시오.

select deptno "부서번호", trunc(avg(sal)) "평균급여", max(sal) "최고급여", min(sal) "최저급여", count(*) "사원수"
from emp
group by deptno;

--SELECT 
--FROM
--WHERE
--GROUP BY
--WHERE
--HAVING
--ORDER BY


--Ex002
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--같은직책(JOB)에 종사하는 사원이 3명 이상인 직책과 인원수를 출력하시오.

select job, count(*)
from emp
group by grouping sets(job)
having count(*) >= 3  -- 기억
order by COUNT(*) DESC, JOB DESC;


--Ex003
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--사원들의 입사년도(HIRE_YEAR)를 기준으로 부서별 몇명이 입사했는지 조회하시오.

select to_char(hiredate, 'yyyy') HIRE_YEAR, deptno, count(*) CNT
from emp
group by to_char(hiredate, 'yyyy'), (deptno)
order by deptno;

SELECT  TO_CHAR( HIREDATE, 'YYYY') HIRE_YEAR , DEPTNO, COUNT(*) CNT 
FROM    EMP
GROUP BY TO_CHAR( HIREDATE, 'YYYY'), DEPTNO -- 순서지정밑 그룹지정할떄 정확한 이름으로 함수명 포함해서
ORDER BY TO_CHAR( HIREDATE, 'YYYY'), DEPTNO;

--Ex004
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--추가수당(COMM)을 받는 사원수와 받지않는 사원수를 조회하시오.

SELECT  NVL2( COMM , 'O' , 'X') EXIST_COMM , COUNT(*) CNT
FROM     EMP
GROUP BY NVL2(COMM,'O','X');


SELECT DECODE(COMM, NULL, 'O', 'X'), COUNT(*) CNT
FROM EMP
GROUP BY DECODE(COMM, NULL, 'O', 'X');

SELECT 
CASE WHEN COMM IS NULL THEN 'X' ELSE 'O' END 
EXITM_COMM, COUNT(*) CNT
FROM    EMP
GROUP BY CASE WHEN COMM IS NULL THEN 'X' ELSE 'O' END;


--Ex005
--EMP 테이블을 이용하여 다음과 같이 출력하시오.
--각 부서의 입사연도별 사원수, 최고급여, 급여합, 평균급여를 출력하고
--각 부서별 소계와 총계를 출력하시오. (ROLLUP)


select DEPTNO, TO_CHAR(HIREDATE, 'YYYY') HIRE_YEAR, COUNT(*), MAX(SAL), SUM(SAL), AVG(SAL)
from emp
group by ROLLUP(DEPTNO, TO_CHAR(HIREDATE, 'YYYY'));
