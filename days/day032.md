ORACLE (SQL)

#1. 저장단위 
변수 < 배열 < 클래스 < 콜렉션프레임워크 > file > DB 
※ DB( mysql , oralce , mssql )

> java : jdbc → dbcp → orm (★mybatis , jpa(세세한코드를 다룰순없음))

#2. RDB (Relational Database)   ★
 -   관계형 데이터 베이스 
 -   테이블 관계
1. 엔티티(entity)     - 테이블  - 관리할 대상 (고객, 주문, 상품)
2. 속성(Attribute)    - 컬럼   - 대상의 특징 (주민번호, 이름, 주문번호)
3. 관계(Relationship) - 외래키 - 대상간의 연결    - 고객은 주문을 한다

#3. 데이터베이스 언어 ★ 

1. 정의어(DDL) - create(만들기) , alter(수정), drop(삭제)   ..... cad (암기법)
2. 조작어(DML) - insert(삽입) , select(조회), update(수정), delete(지우기)..... crud(암기법)
3. 제어어(DCL) - grant(권한부여) , revoke(권한회수)

4. select



<<사원>>
> desc emp;

SQL> desc emp;
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 EMPNO                                     NOT NULL NUMBER(4)
 ENAME                                              VARCHAR2(10)
 JOB                                                VARCHAR2(9)
 MGR                                                NUMBER(4)
 HIREDATE                                           DATE
 SAL                                                NUMBER(7,2)
 COMM                                               NUMBER(7,2)
 DEPTNO                                             NUMBER(2)


<<부서>>
SQL > desc dept;         


 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 DEPTNO                                    NOT NULL NUMBER(2)
 DNAME                                              VARCHAR2(14)
 LOC                                                VARCHAR2(13)



> 부서는 많은 사원을 가질 수 있다.
관리대상 (table) : dept          emp
속성     (attribute) deptno     empno , deptno  ,,,
연결(Relationship) : 

#4. SELECFT

[실습]

1. 테이블 구조확인 : desc emp
2. 테이블 전체정보확인 : select * from emp;



1. c(insert)    , r(select)
2. 

-- 기타



-- #1. 테이블구조확인
desc emp;
desc dept;

show user;  -- 실행 ) 현재줄 선택하고 ctrl + enter
select table_name from user_tables; -- 사용할 수 있는 테이블 확인 

-- #2. 전체 테이블 조회
select * from emp;

-- #3. 열조회
select empno, ename from emp;
select ename, job   from emp;

-- #4. 중복제거 (distinct)
select distinct job from emp;
select all      job from emp;

-- #5. 연산 및 별칭
desc emp;

-- 3달치 급여
select ename "유저", sal as "월급" , sal+sal+sal  as "3달치 월급"   from emp;

-- #6. 정렬
select ename, sal from emp order by sal asc;   -- asc는 오름차순
select ename, sal from emp order by sal desc;   -- desc는 내림차순



-- ## step 연습문제
-- https://sally03915.github.io/stackventure_250825/004_oracle/oracle002_select_basic#15


-- Q1. emp 테이블구성
desc emp;

-- Q2. 
desc dept;

-- Q3. 
desc SALGRADE;

-- Q4.
select * from emp;

-- Q5. 
select EMPNO, ENAME, DEPTNO from emp;

-- Q6.
select distinct DEPTNO from emp;

-- Q7.
select distinct JOB, DEPTNO from emp;

-- Q8.  emp 테이블에서 job, deptno 열중복제거하지 말고
select ALL JOB, DEPTNO from emp;    -- all 생략해도 같은?
select     job, deptno from emp;

-- Q9. emp 테이블에서 연산식 연간총수입
select ENAME, SAL, SAL*12+COMM, COMM from emp;

-- Q10. emp 테이블에서 열+열 더하기 연산식
select ENAME, SAL, (SAL*12)+COMM,COMM from emp;
select ENAME, SAL, SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+COMM,COMM from emp;

-- Q11. emp 테이블에서 연간총수입으로 별칭 붙이기
select ENAME, SAL, (SAL*12)+COMM as "ANNSAL", COMM from emp;

-- Q12.
select * from emp order by SAL asc;
select * from emp order by SAL ; -- asc는 생략가능

-- Q13.
select * from emp order by SAL desc;

-- Q14. 
select * from emp order by DEPTNO asc, SAL desc;

-- ※ 테이블 emp
-- 사용가능한 테이블 확인
select table_name from user_tables;

-- emp 테이블삭제 (복구X)
drop table emp;
select table_name from user_tables;

-- emp 테이블 만들기 정의어(DDL) - CREATE, ALTER, DROP
CREATE TABLE emp (
  empno NUMBER(4),
  ename VARCHAR2(10),
  job VARCHAR2(9),
  mgr NUMBER(4),
  hiredate DATE,
  sal NUMBER(7,2),
  comm NUMBER(7,2),
  deptno NUMBER(2)
);
desc emp; -- 관리대상

-- emp 테이블 값넣기  2. 조작어 (DML)   - INSERT(삽입) , SELECT(조회), UPDATE(수정), DELETE(지우기) 
INSERT INTO emp VALUES (7839, 'KING', 'PRESIDENT', NULL, TO_DATE('1981-11-17','YYYY-MM-DD'), 5000, NULL, 10);
INSERT INTO emp VALUES (7698, 'BLAKE', 'MANAGER', 7839, TO_DATE('1981-05-01','YYYY-MM-DD'), 2850, NULL, 30);
INSERT INTO emp VALUES (7782, 'CLARK', 'MANAGER', 7839, TO_DATE('1981-06-09','YYYY-MM-DD'), 2450, NULL, 10);
INSERT INTO emp VALUES (7566, 'JONES', 'MANAGER', 7839, TO_DATE('1981-04-02','YYYY-MM-DD'), 2975, NULL, 20);
INSERT INTO emp VALUES (7902, 'FORD', 'ANALYST', 7566, TO_DATE('1981-12-03','YYYY-MM-DD'), 3000, NULL, 20);
INSERT INTO emp VALUES (7369, 'SMITH', 'CLERK', 7902, TO_DATE('1980-12-17','YYYY-MM-DD'), 800, NULL, 20);
INSERT INTO emp VALUES (7788, 'SCOTT', 'ANALYST', 7566, TO_DATE('1987-07-13','YYYY-MM-DD'), 3000, NULL, 20);
INSERT INTO emp VALUES (7876, 'ADAMS', 'CLERK', 7788, TO_DATE('1987-07-13','YYYY-MM-DD'), 1100, NULL, 20);
INSERT INTO emp VALUES (7934, 'MILLER', 'CLERK', 7782, TO_DATE('1982-01-23','YYYY-MM-DD'), 1300, NULL, 10);
INSERT INTO emp VALUES (7654, 'MARTIN', 'SALESMAN', 7698, TO_DATE('1981-09-28','YYYY-MM-DD'), 1250, 1400, 30);
INSERT INTO emp VALUES (7499, 'ALLEN', 'SALESMAN', 7698, TO_DATE('1981-02-20','YYYY-MM-DD'), 1600, 300, 30);
INSERT INTO emp VALUES (7844, 'TURNER', 'SALESMAN', 7698, TO_DATE('1981-09-08','YYYY-MM-DD'), 1500, 0, 30);
INSERT INTO emp VALUES (7900, 'JAMES', 'CLERK', 7698, TO_DATE('1981-12-03','YYYY-MM-DD'), 950, NULL, 30);
INSERT INTO emp VALUES (7521, 'WARD', 'SALESMAN', 7698, TO_DATE('1981-02-22','YYYY-MM-DD'), 1250, 500, 30);

commit; -- 삽입[반영]

delete from emp;

-- ex 1 
select distinct JOB from emp;

-- ex 2
select * from emp;
select EMPNO AS EMPLOYEE_NO, ENAME AS EMPLOYEE_NAME, MGR AS MANAGER, SAL AS SALARY, COMM AS COMMISSION, DEPTNO AS DEPARTMENT_NO FROM AS EMP; -- AS 생략가능 영문은 "" 생략가능
select EMPNO EMPLOYEE_NO, ENAME EMPLOYEE_NAME, MGR MANAGER, SAL SALARY, COMM COMMISSION, DEPTNO DEPARTMENT_NO FROM EMP order by deptno desc, ename asc; -- asc 생략가능 순서정렬 우선순위 앞부터



-- 조건에 맞는 데이터 조회 
-- #1. where       
-- #2. 비교연산자 : (같다) =, (다르다) != , <> , ^= 
-- #3. 논리연산자 : AND / BETWEEN     AND (범위지정) , OR / IN , NOT
-- #4. like      : 패턴검색
-- #5. null 처리  : NULL 여부확인
-- #6. 집합연산자 : union (중복제거하고 합집합) , union all (중복 포함하고 합집합) , minus(차집합), intersect(교집합)



-- 조건에 맞는 데이터 조회 
-- #1. where       
-- #2. 비교연산자 : (같다) =, (다르다) != , <> , ^= 
-- #3. 논리연산자 : AND / BETWEEN     AND (범위지정) , OR / IN , NOT
-- #4. like      : 패턴검색
-- #5. null 처리  : NULL 여부확인
-- #6. 집합연산자 : union (중복제거하고 합집합) , union all (중복 포함하고 합집합) , minus(차집합), intersect(교집합)


-- #1. 전체데이터 조회
select * from emp;

-- #2. where 조건조회
select * from emp where empno  =7839;    -- 같다 =
select * from emp where empno !=7839;   -- 다르다 !=
select * from emp where empno <>7839;   -- 다르다 <>
select * from emp where empno ^=7839;   -- 다르다 ^=

select * from emp where ename='KING';

select * from emp where empno=7839 and ename='KING';    -- and 두가지다 조건이 맞아야함.
select * from emp where empno=7839 and ename='SCOTT';   -- x 결과물 미출력(조건해당없음)
select * from emp where empno=7839 or  ename='SCOTT';   -- or 또는 둘 중에 하나

select * from emp where sal*12 = 36000; 
select * from emp where sal >= 3000; 

select * from emp where ename >= 'S' ; -- S이상의 문자열으로 시작하는 이름
select * from emp where ename <= 'SOR' ; -- 우선순위? 123?

select * from emp where deptno>=20 and deptno<=40;  -- >= , <= 
select * from emp where deptno between 20 and 30;   -- between and는 이상과 이하

select * from emp where deptno=10 or deptno=30;
select * from emp where deptno in(10,30);

select * from emp where ename = 'KING';     -- 이름이 알때
select * from emp where ename LIKE 'A%';    -- 이름이 A로 시작하는
select * from emp where ename LIKE '%A%';   -- 이름이 A가 중간에 있는
select * from emp where ename LIKE '%G';    -- 이름이 G로 끝나는
select * from emp where ename LIKE '_I%';   -- _(첫글자, 아무거나) 두번쨰 글자가 I

select * from emp where comm = null;        -- X null (데이터 없어 - 상태)
select * from emp where comm is null;       -- 커미션이 존재하지 않는
select * from emp where comm is not null;   -- 커미션이 존재하는 


--Q1 
select * from emp;
--Q2 부서번호가 30인데이터
select * from emp where DEPTNO = 30;
--Q3
select * from emp where DEPTNO = 30 and JOB = 'SALESMAN';
--Q4
select * from emp where DEPTNO = 30 or JOB = 'CLERK';

--Q5. sal 12를 곱한값이 36000인행을 조회
select * from emp where SAL* 12 = 36000;

select * from emp;

-- SQL처리순서 ( from → where → select )
--select  *                3. * (모든 컬럼값)
--from   emp               1. emp 테이블 읽어오기
--where sal * 12 = 36000  2. 각행에대해( 한 명 자료묶음 ) sal*12=36000 조건평가


--Q6. sal  3000이상인 행
select * from emp where SAL >= 3000;

--Q7 ENAME이 F이상인 열
select * from emp where ENAME >= 'F';   -- 틀림

--Q8
select * from emp where ENAME LIKE 'F%' or ENAME LIKE '_O%' or ENAME LIKE '__R%' or ENAME LIKE '___Z%'; -- 틀림
select * from emp where ENAME <= 'FORZ';

--Q9
select * from emp where SAL != 3000;

--Q10
select * from emp where SAL <> 3000;

--Q11
select * from emp where SAL ^= 3000;

--Q12 
select * from emp where NOT SAL = 3000; -- 틀림

--Q13. emp테이블에서 or 를 이용하여
select * from emp where JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';

--Q14. emp테이블에서 in 를 이용하여
--JOB 열이 'MANAGER', 'SALESMAN', 'CLERK' 중 하나라도 포함되는 행을 조회
-- FROM → where → select
select * from emp where JOB IN ('MANAGER', 'SALESMAN', 'CLERK');

--Q15. EMP 테이블에서 등가연산자 (!=
select * from emp 
where JOB != 'MANAGER' 
AND JOB <> 'SALESMAN' 
AND JOB ^= 'CLERK';

--Q16
select * from emp where JOB NOT IN ('MANAGER', 'SALESMAN', 'CLERK');

--Q17
select * from emp where SAL >= 2000 and SAL <= 3000;

--Q18
select * from emp where SAL BETWEEN 2000 AND 3000;

--Q19
select * from emp where SAL NOT BETWEEN 2000 AND 3000 ; 

--Q20
select * from emp where ENAME LIKE 'S%';

--Q21
select * from emp where ENAME LIKE '_L%'; -- 대소문자 구분

--Q22
select * from emp where ENAME LIKE '%AM%';

--Q23
select * from emp where ENAME NOT LIKE '%AM%'; -- 틀림

--Q24
select ENAME, SAL, SAL * 12 + COMM AS ANNSAL, COMM from emp; 

--select e.ENAME 이름, e.SAL 급여, SAL * 12 + COMM AS ANNSAL, COMM from emp e; 
-- 별명 사용가능 

--select      *
--from
--where
--order by desc, asc;

--Q25
--비어있는 상태
select * from emp where comm = null;
--Q26
select * from emp where COMM is null;
--Q27. emp 테이블에서 mgr열이 null 이 아닌행 
select * from emp where MGR is not null;
--Q28
select * from emp where sal > null and comm is null;
--                            x  (false) and true;        
--사용은 가능하나 sal > null은 비어있는 상태이기 때문에 비교불가(값이안나옴)
--모든 범위를 출력, EMP에서, SAL이 NULL 보다 높은것 그리고, COMM 상태가 NULL인 것을 출력;

--Q29
select * from emp where sal > null or comm is null;
-- emp의 모든 범위에서 SAL > NULL 또는 COMM 상태가 NULL; 인것을 출력
--                                x (false) or true;   
select distinct DEPTNO from emp;




```Java


package com.company.java014;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

// 1. 콜렉션 프레임 워크 - [배열]의 단점을 개선한 [객체]만 저장가능 [동적배열]
// 2. List, Set, Map
// List (기차) - index 순서 O , 중복허용 O , add / get(순서) / size / remove(순서) / contains
// Set (주머니) - index 순서 x , 중복허용 X , add / 향상된 for, iterator / size / remove(객체) / contains

class Candy{
	String name;
	int    price;
	public Candy() { super(); }
	public Candy(String name, int price) { super(); this.name = name; this.price = price; }	
	@Override public String toString() { return "Candy [name=" + name + ", price=" + price + "]"; }
	// 1. Candy 클래스 확인용도
	@Override public int hashCode() { return Objects.hash(name, price); }
	// 2. 사용자가 넣어준값을 비교
	@Override public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (getClass() != obj.getClass()) return false;
		Candy other = (Candy) obj;
		return Objects.equals(name, other.name) && price == other.price;
	}
	
}
public class Set001 {
	public static void main(String[] args) {
		Set<Integer> set1 = new HashSet<>();
		set1.add(new Integer(1)); // Integer e = new Integer(1) (부품객체)
		set1.add(1);			  // Integer e = 1	 ( 기본값 )
		set1.add(1);			  // 부품객체     = 기본값	(Integer - wrapper 클래스)
		set1.add(2);		      // 기본값을 자동으로 - 객체화 - 부품객체 (wrapper 클래스)
		set1.add(3);			  // int → Integer , float → Float 오토박싱.
		System.out.println( set1 );
		
		Set<Candy> set2 = new HashSet<>();
		set2.add(new Candy("츕파츕스"		, 300));
		set2.add(new Candy("츕파츕스"		, 300));
		set2.add(new Candy("츕파츕스"		, 300));
		set2.add(new Candy("청포도알사탕"	, 4500));
		set2.add(new Candy("멘톨"			, 5500));
		System.out.println(set2);
		System.out.println(set2.size());
		
	}

}
```
자바에서 Set사용법

```Java
package com.company.java014;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

//1. 콜렉션 프레임 워크 - [배열]의 단점을 개선한 [객체]만 저장가능 [동적배열]
//2. List, Set, Map
//List (기차) - index 순서 O , 중복허용 O , add / get(순서) / size / remove(순서) / contains
//Set (주머니) - index 순서 x , 중복허용 X , add / 향상된 for, iterator / size / remove(객체) / contains
//Map (사전)  - key:value → entry 한쌍 , put  / get(key) , 향상된 for, iterator / size / remove(객체) / contains 

public class Map001 {
	public static void main(String[] args) {
		Map<String, Integer> map = new HashMap<>();
		map.put("one"  , 1); //키, 값
		map.put("two"  , 2); //키, 값
		map.put("three", 3); //키, 값
		
		System.out.println("1 : " + map);
		System.out.println("2 : " + map.get("two"));
		System.out.println("3 : " + map.size());
		System.out.println("4 : " + map.remove("two"));
		System.out.println("4 : " + map.containsKey("one"));
		System.out.println(map.entrySet());	// key:value 한묶음, 한쌍 - [one=1, three=3]
		
		for ( Entry<String, Integer> one : map.entrySet()) { 
			System.out.println(one.getKey() + "/" + one.getValue());
		}
		Iterator<Entry<String, Integer>> iter	 =		map.entrySet().iterator();	// iter → [one=1, three=3]
		while(iter.hasNext()) {// 2) 처리대상확인 [iter → one=1, three=3]
			Entry<String, Integer> temp = iter.next(); // [one=1]
			System.out.println( temp.getKey() + "/" + temp.getValue());
		}
	}

}
```
자바에서 Map사용법