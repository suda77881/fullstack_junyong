ORACLE (SQL)

#1. 저장단위 
변수 < 배열 < 클래스 < 콜렉션프레임워크 > file > DB 
※ DB( mysql , oralce , mssql )

> java : jdbc → dbcp → orm (★mybatis , jpa(세세한코드를 다룰순없음))

#2. RDB (Relational Database)   ★
 -   관계형 데이터 베이스 
 -   테이블 관계
1. 엔티티(entity)     - 테이블  - 관리할 대상 (고객, 주문, 상품)
2. 속성(Attribute)    - 컬럼   - 대상의 특징 (주민번호, 이름, 주문번호)
3. 관계(Relationship) - 외래키 - 대상간의 연결    - 고객은 주문을 한다

#3. 데이터베이스 언어 ★ 

1. 정의어(DDL) - create(만들기) , alter(수정), drop(삭제)   ..... cad (암기법)
2. 조작어(DML) - insert(삽입) , select(조회), update(수정), delete(지우기)..... crud(암기법)
3. 제어어(DCL) - grant(권한부여) , revoke(권한회수)

4. select



<<사원>>
> desc emp;

SQL> desc emp;
 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 EMPNO                                     NOT NULL NUMBER(4)
 ENAME                                              VARCHAR2(10)
 JOB                                                VARCHAR2(9)
 MGR                                                NUMBER(4)
 HIREDATE                                           DATE
 SAL                                                NUMBER(7,2)
 COMM                                               NUMBER(7,2)
 DEPTNO                                             NUMBER(2)


<<부서>>
SQL > desc dept;         


 Name                                      Null?    Type
 ----------------------------------------- -------- ----------------------------
 DEPTNO                                    NOT NULL NUMBER(2)
 DNAME                                              VARCHAR2(14)
 LOC                                                VARCHAR2(13)



> 부서는 많은 사원을 가질 수 있다.
관리대상 (table) : dept          emp
속성     (attribute) deptno     empno , deptno  ,,,
연결(Relationship) : 

#4. SELECFT

[실습]

1. 테이블 구조확인 : desc emp
2. 테이블 전체정보확인 : select * from emp;



1. c(insert)    , r(select)
2. 

-- 기타



-- #1. 테이블구조확인
desc emp;
desc dept;

show user;  -- 실행 ) 현재줄 선택하고 ctrl + enter
select table_name from user_tables; -- 사용할 수 있는 테이블 확인 

-- #2. 전체 테이블 조회
select * from emp;

-- #3. 열조회
select empno, ename from emp;
select ename, job   from emp;

-- #4. 중복제거 (distinct)
select distinct job from emp;
select all      job from emp;

-- #5. 연산 및 별칭
desc emp;

-- 3달치 급여
select ename "유저", sal as "월급" , sal+sal+sal  as "3달치 월급"   from emp;

-- #6. 정렬
select ename, sal from emp order by sal asc;   -- asc는 오름차순
select ename, sal from emp order by sal desc;   -- desc는 내림차순



-- ## step 연습문제
-- https://sally03915.github.io/stackventure_250825/004_oracle/oracle002_select_basic#15


-- Q1. emp 테이블구성
desc emp;

-- Q2. 
desc dept;

-- Q3. 
desc SALGRADE;

-- Q4.
select * from emp;

-- Q5. 
select EMPNO, ENAME, DEPTNO from emp;

-- Q6.
select distinct DEPTNO from emp;

-- Q7.
select distinct JOB, DEPTNO from emp;

-- Q8.  emp 테이블에서 job, deptno 열중복제거하지 말고
select ALL JOB, DEPTNO from emp;    -- all 생략해도 같은?
select     job, deptno from emp;

-- Q9. emp 테이블에서 연산식 연간총수입
select ENAME, SAL, SAL*12+COMM, COMM from emp;

-- Q10. emp 테이블에서 열+열 더하기 연산식
select ENAME, SAL, (SAL*12)+COMM,COMM from emp;
select ENAME, SAL, SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+SAL+COMM,COMM from emp;

-- Q11. emp 테이블에서 연간총수입으로 별칭 붙이기
select ENAME, SAL, (SAL*12)+COMM as "ANNSAL", COMM from emp;

-- Q12.
select * from emp order by SAL asc;
select * from emp order by SAL ; -- asc는 생략가능

-- Q13.
select * from emp order by SAL desc;

-- Q14. 
select * from emp order by DEPTNO asc, SAL desc;

-- ※ 테이블 emp
-- 사용가능한 테이블 확인
select table_name from user_tables;

-- emp 테이블삭제 (복구X)
drop table emp;
select table_name from user_tables;

-- emp 테이블 만들기 정의어(DDL) - CREATE, ALTER, DROP
CREATE TABLE emp (
  empno NUMBER(4),
  ename VARCHAR2(10),
  job VARCHAR2(9),
  mgr NUMBER(4),
  hiredate DATE,
  sal NUMBER(7,2),
  comm NUMBER(7,2),
  deptno NUMBER(2)
);
desc emp; -- 관리대상

-- emp 테이블 값넣기  2. 조작어 (DML)   - INSERT(삽입) , SELECT(조회), UPDATE(수정), DELETE(지우기) 
INSERT INTO emp VALUES (7839, 'KING', 'PRESIDENT', NULL, TO_DATE('1981-11-17','YYYY-MM-DD'), 5000, NULL, 10);
INSERT INTO emp VALUES (7698, 'BLAKE', 'MANAGER', 7839, TO_DATE('1981-05-01','YYYY-MM-DD'), 2850, NULL, 30);
INSERT INTO emp VALUES (7782, 'CLARK', 'MANAGER', 7839, TO_DATE('1981-06-09','YYYY-MM-DD'), 2450, NULL, 10);
INSERT INTO emp VALUES (7566, 'JONES', 'MANAGER', 7839, TO_DATE('1981-04-02','YYYY-MM-DD'), 2975, NULL, 20);
INSERT INTO emp VALUES (7902, 'FORD', 'ANALYST', 7566, TO_DATE('1981-12-03','YYYY-MM-DD'), 3000, NULL, 20);
INSERT INTO emp VALUES (7369, 'SMITH', 'CLERK', 7902, TO_DATE('1980-12-17','YYYY-MM-DD'), 800, NULL, 20);
INSERT INTO emp VALUES (7788, 'SCOTT', 'ANALYST', 7566, TO_DATE('1987-07-13','YYYY-MM-DD'), 3000, NULL, 20);
INSERT INTO emp VALUES (7876, 'ADAMS', 'CLERK', 7788, TO_DATE('1987-07-13','YYYY-MM-DD'), 1100, NULL, 20);
INSERT INTO emp VALUES (7934, 'MILLER', 'CLERK', 7782, TO_DATE('1982-01-23','YYYY-MM-DD'), 1300, NULL, 10);
INSERT INTO emp VALUES (7654, 'MARTIN', 'SALESMAN', 7698, TO_DATE('1981-09-28','YYYY-MM-DD'), 1250, 1400, 30);
INSERT INTO emp VALUES (7499, 'ALLEN', 'SALESMAN', 7698, TO_DATE('1981-02-20','YYYY-MM-DD'), 1600, 300, 30);
INSERT INTO emp VALUES (7844, 'TURNER', 'SALESMAN', 7698, TO_DATE('1981-09-08','YYYY-MM-DD'), 1500, 0, 30);
INSERT INTO emp VALUES (7900, 'JAMES', 'CLERK', 7698, TO_DATE('1981-12-03','YYYY-MM-DD'), 950, NULL, 30);
INSERT INTO emp VALUES (7521, 'WARD', 'SALESMAN', 7698, TO_DATE('1981-02-22','YYYY-MM-DD'), 1250, 500, 30);

commit; -- 삽입[반영]

delete from emp;

-- ex 1 
select distinct JOB from emp;

-- ex 2
select * from emp;
select EMPNO AS EMPLOYEE_NO, ENAME AS EMPLOYEE_NAME, MGR AS MANAGER, SAL AS SALARY, COMM AS COMMISSION, DEPTNO AS DEPARTMENT_NO FROM AS EMP; -- AS 생략가능 영문은 "" 생략가능
select EMPNO EMPLOYEE_NO, ENAME EMPLOYEE_NAME, MGR MANAGER, SAL SALARY, COMM COMMISSION, DEPTNO DEPARTMENT_NO FROM EMP order by deptno desc, ename asc; -- asc 생략가능 순서정렬 우선순위 앞부터



-- 조건에 맞는 데이터 조회 
-- #1. where       
-- #2. 비교연산자 : (같다) =, (다르다) != , <> , ^= 
-- #3. 논리연산자 : AND / BETWEEN     AND (범위지정) , OR / IN , NOT
-- #4. like      : 패턴검색
-- #5. null 처리  : NULL 여부확인
-- #6. 집합연산자 : union (중복제거하고 합집합) , union all (중복 포함하고 합집합) , minus(차집합), intersect(교집합)



-- 조건에 맞는 데이터 조회 
-- #1. where       
-- #2. 비교연산자 : (같다) =, (다르다) != , <> , ^= 
-- #3. 논리연산자 : AND / BETWEEN     AND (범위지정) , OR / IN , NOT
-- #4. like      : 패턴검색
-- #5. null 처리  : NULL 여부확인
-- #6. 집합연산자 : union (중복제거하고 합집합) , union all (중복 포함하고 합집합) , minus(차집합), intersect(교집합)


-- #1. 전체데이터 조회
select * from emp;

-- #2. where 조건조회
select * from emp where empno  =7839;    -- 같다 =
select * from emp where empno !=7839;   -- 다르다 !=
select * from emp where empno <>7839;   -- 다르다 <>
select * from emp where empno ^=7839;   -- 다르다 ^=

select * from emp where ename='KING';

select * from emp where empno=7839 and ename='KING';    -- and 두가지다 조건이 맞아야함.
select * from emp where empno=7839 and ename='SCOTT';   -- x 결과물 미출력(조건해당없음)
select * from emp where empno=7839 or  ename='SCOTT';   -- or 또는 둘 중에 하나

select * from emp where sal*12 = 36000; 
select * from emp where sal >= 3000; 

select * from emp where ename >= 'S' ; -- S이상의 문자열으로 시작하는 이름
select * from emp where ename <= 'SOR' ; -- 우선순위? 123?

select * from emp where deptno>=20 and deptno<=40;  -- >= , <= 
select * from emp where deptno between 20 and 30;   -- between and는 이상과 이하

select * from emp where deptno=10 or deptno=30;
select * from emp where deptno in(10,30);

select * from emp where ename = 'KING';     -- 이름이 알때
select * from emp where ename LIKE 'A%';    -- 이름이 A로 시작하는
select * from emp where ename LIKE '%A%';   -- 이름이 A가 중간에 있는
select * from emp where ename LIKE '%G';    -- 이름이 G로 끝나는
select * from emp where ename LIKE '_I%';   -- _(첫글자, 아무거나) 두번쨰 글자가 I

select * from emp where comm = null;        -- X null (데이터 없어 - 상태)
select * from emp where comm is null;       -- 커미션이 존재하지 않는
select * from emp where comm is not null;   -- 커미션이 존재하는 


--Q1 
select * from emp;
--Q2 부서번호가 30인데이터
select * from emp where DEPTNO = 30;
--Q3
select * from emp where DEPTNO = 30 and JOB = 'SALESMAN';
--Q4
select * from emp where DEPTNO = 30 or JOB = 'CLERK';

--Q5. sal 12를 곱한값이 36000인행을 조회
select * from emp where SAL* 12 = 36000;

select * from emp;

-- SQL처리순서 ( from → where → select )
--select  *                3. * (모든 컬럼값)
--from   emp               1. emp 테이블 읽어오기
--where sal * 12 = 36000  2. 각행에대해( 한 명 자료묶음 ) sal*12=36000 조건평가


--Q6. sal  3000이상인 행
select * from emp where SAL >= 3000;

--Q7 ENAME이 F이상인 열
select * from emp where ENAME >= 'F';   -- 틀림

--Q8
select * from emp where ENAME LIKE 'F%' or ENAME LIKE '_O%' or ENAME LIKE '__R%' or ENAME LIKE '___Z%'; -- 틀림
select * from emp where ENAME <= 'FORZ';

--Q9
select * from emp where SAL != 3000;

--Q10
select * from emp where SAL <> 3000;

--Q11
select * from emp where SAL ^= 3000;

--Q12 
select * from emp where NOT SAL = 3000; -- 틀림

--Q13. emp테이블에서 or 를 이용하여
select * from emp where JOB = 'MANAGER' OR JOB = 'SALESMAN' OR JOB = 'CLERK';

--Q14. emp테이블에서 in 를 이용하여
--JOB 열이 'MANAGER', 'SALESMAN', 'CLERK' 중 하나라도 포함되는 행을 조회
-- FROM → where → select
select * from emp where JOB IN ('MANAGER', 'SALESMAN', 'CLERK');

--Q15. EMP 테이블에서 등가연산자 (!=
select * from emp 
where JOB != 'MANAGER' 
AND JOB <> 'SALESMAN' 
AND JOB ^= 'CLERK';

--Q16
select * from emp where JOB NOT IN ('MANAGER', 'SALESMAN', 'CLERK');

--Q17
select * from emp where SAL >= 2000 and SAL <= 3000;

--Q18
select * from emp where SAL BETWEEN 2000 AND 3000;

--Q19
select * from emp where SAL NOT BETWEEN 2000 AND 3000 ; 

--Q20
select * from emp where ENAME LIKE 'S%';

--Q21
select * from emp where ENAME LIKE '_L%'; -- 대소문자 구분

--Q22
select * from emp where ENAME LIKE '%AM%';

--Q23
select * from emp where ENAME NOT LIKE '%AM%'; -- 틀림

--Q24
select ENAME, SAL, SAL * 12 + COMM AS ANNSAL, COMM from emp; 

--select e.ENAME 이름, e.SAL 급여, SAL * 12 + COMM AS ANNSAL, COMM from emp e; 
-- 별명 사용가능 

--select      *
--from
--where
--order by desc, asc;

--Q25
--비어있는 상태
select * from emp where comm = null;
--Q26
select * from emp where COMM is null;
--Q27. emp 테이블에서 mgr열이 null 이 아닌행 
select * from emp where MGR is not null;
--Q28
select * from emp where sal > null and comm is null;
--                            x  (false) and true;        
--사용은 가능하나 sal > null은 비어있는 상태이기 때문에 비교불가(값이안나옴)
--모든 범위를 출력, EMP에서, SAL이 NULL 보다 높은것 그리고, COMM 상태가 NULL인 것을 출력;

--Q29
select * from emp where sal > null or comm is null;
-- emp의 모든 범위에서 SAL > NULL 또는 COMM 상태가 NULL; 인것을 출력
--                                x (false) or true;   
select distinct DEPTNO from emp;




```Java


package com.company.java014;

import java.util.HashSet;
import java.util.Objects;
import java.util.Set;

// 1. 콜렉션 프레임 워크 - [배열]의 단점을 개선한 [객체]만 저장가능 [동적배열]
// 2. List, Set, Map
// List (기차) - index 순서 O , 중복허용 O , add / get(순서) / size / remove(순서) / contains
// Set (주머니) - index 순서 x , 중복허용 X , add / 향상된 for, iterator / size / remove(객체) / contains

class Candy{
	String name;
	int    price;
	public Candy() { super(); }
	public Candy(String name, int price) { super(); this.name = name; this.price = price; }	
	@Override public String toString() { return "Candy [name=" + name + ", price=" + price + "]"; }
	// 1. Candy 클래스 확인용도
	@Override public int hashCode() { return Objects.hash(name, price); }
	// 2. 사용자가 넣어준값을 비교
	@Override public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (getClass() != obj.getClass()) return false;
		Candy other = (Candy) obj;
		return Objects.equals(name, other.name) && price == other.price;
	}
	
}
public class Set001 {
	public static void main(String[] args) {
		Set<Integer> set1 = new HashSet<>();
		set1.add(new Integer(1)); // Integer e = new Integer(1) (부품객체)
		set1.add(1);			  // Integer e = 1	 ( 기본값 )
		set1.add(1);			  // 부품객체     = 기본값	(Integer - wrapper 클래스)
		set1.add(2);		      // 기본값을 자동으로 - 객체화 - 부품객체 (wrapper 클래스)
		set1.add(3);			  // int → Integer , float → Float 오토박싱.
		System.out.println( set1 );
		
		Set<Candy> set2 = new HashSet<>();
		set2.add(new Candy("츕파츕스"		, 300));
		set2.add(new Candy("츕파츕스"		, 300));
		set2.add(new Candy("츕파츕스"		, 300));
		set2.add(new Candy("청포도알사탕"	, 4500));
		set2.add(new Candy("멘톨"			, 5500));
		System.out.println(set2);
		System.out.println(set2.size());
		
	}

}
```
자바에서 Set사용법

```Java
package com.company.java014;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;

//1. 콜렉션 프레임 워크 - [배열]의 단점을 개선한 [객체]만 저장가능 [동적배열]
//2. List, Set, Map
//List (기차) - index 순서 O , 중복허용 O , add / get(순서) / size / remove(순서) / contains
//Set (주머니) - index 순서 x , 중복허용 X , add / 향상된 for, iterator / size / remove(객체) / contains
//Map (사전)  - key:value → entry 한쌍 , put  / get(key) , 향상된 for, iterator / size / remove(객체) / contains 

public class Map001 {
	public static void main(String[] args) {
		Map<String, Integer> map = new HashMap<>();
		map.put("one"  , 1); //키, 값
		map.put("two"  , 2); //키, 값
		map.put("three", 3); //키, 값
		
		System.out.println("1 : " + map);
		System.out.println("2 : " + map.get("two"));
		System.out.println("3 : " + map.size());
		System.out.println("4 : " + map.remove("two"));
		System.out.println("4 : " + map.containsKey("one"));
		System.out.println(map.entrySet());	// key:value 한묶음, 한쌍 - [one=1, three=3]
		
		for ( Entry<String, Integer> one : map.entrySet()) { 
			System.out.println(one.getKey() + "/" + one.getValue());
		}
		Iterator<Entry<String, Integer>> iter	 =		map.entrySet().iterator();	// iter → [one=1, three=3]
		while(iter.hasNext()) {// 2) 처리대상확인 [iter → one=1, three=3]
			Entry<String, Integer> temp = iter.next(); // [one=1]
			System.out.println( temp.getKey() + "/" + temp.getValue());
		}
	}

}
```
자바에서 Map사용법




## Track001 -  github
 
# ■ ORACLE
# ■ 001. Setting

1. sqld 접수  (~09:40)
   https://www.dataq.or.kr/www/main.do
2. select basic
3. select where



# ■ JAVA
# ■ Java Collection Framework
- List
■ Set
■ Map
  
# ■ Github   
### 12. 깃허브 협업 
..............................
##### ■1. basic
```
#1. 가방에 담기  ( 불꽃마법재료, 불씨,,,)
git  add .

#2. 가방에 메시지남기기 (불꽃마법 완성)
git commit -m "메시지"

#3. [공용-github - 마법책] 같은 마법책을 쓰니깐 서로 바뀐거 확인
git pull origin master

#4. [공용-github - 마법책] 에 불꽃마법 올리기 (공유)
git push origin master

```


##### ■2. 깃협업
1. 팀원초대
2. 협업 중 같은 파일ㅇ르 수정하면서 생기는 충돌(conflict) 해결

```
#1. 팀장 - 팀원초대 (github 웹)
#2. 팀원 - repository 클론
  git clone 깃허브주소

#3. 팀원 - branch
  git checkout -b branch명
#4. 팀원 - 파일작성
 git add .
 git commit -m "message"
 git pull   origin  master 
 git push   origin  master

 ※ 충돌 - HEAD , ====== , >>>>>> / 코드수정

#5. 팀원 - pr 
```

> **Question**
```
Q1. 팀장 - test2.md 파일만들기 > 안녕하세요 포젝트입니다.
Q2. 팀원 - test2.md          > 안녕하세요 팀원 **입니다.
      충돌시- 충돌해결 후 코드 
      안녕하세요 포젝트입니다.
      팀장 : 세상에서 젤로 멋찐 홍길동입니다.
      팀원 : 세상에서 젤로 귀여운 가길동입니다.
```


##### ■3. merge  vs  rebase
1. 기능 브랜치에서 작업 중  main브랜치가 업데이트가 된 경우
> 여러 마법사가 함께 주문서를 쓰고있을때 
- 내가 주문을 다시쓰면 친구들의 주문이 사라 질수 있음.

★  브랜치 꼭확인!
```
#1. 불꽃마법사가 본인코드 작성중  (dev-f)
   git add spell2.md
   git commit -m "불꽃마법2 추가"

#2. 메인 마법서가 업데이트가 됨.
    불꽃마법사가 최신 마법서 위에 자신의 주문을 다시 써야 함.

    git checkout master
    git pull origin master

    # 최신 마법서 위에 주문 다시 쓰기 
    git checkout dev-f
    git rebase master   
    # > master 브랜치기준으로 내작업을 다시 정렬
    # > 주문이 겹쳐서 마법서 충돌남. 어떤 주문 쓸지 선택 / 수정완료

    git add  spell2.md
    git rebase  --continue

    # 안전하게 주문서 공유
    git push  --force-with-lease
```

> **Question1**
```
1.  test2.md 파일에 테이블옆에 본인이모지  🔥 붙이기
2.  rebase 해서 파일 다시 올리기
```

> **Question2**
```
1.  팀장님      - test2.md  ( 깃허브에서 응원의 메시지 남겨주기)
2.  팀원        - test2.md 파일에 본인이 다른친구들한테 또는 본인한테 남기는 응원의 메시지적기 
3.  팀장 + 팀원  - rebase 해서 파일 다시 올리기
```


..............................





# ■ 자기소개페이지 
# ■ 포트폴리오 점검- day31완료!
---
1. html + css + js/jquery      [개인]
2. spring + mybatis + jstl     
3. spring boot + thymeleaf + jpa + mybatis + react  
4. node + react
5. flutter + spring boot + jpa + mybatis + react


> 복습문제
```sql
-- Ex1  emp 테이블에서 job 데이터 중복없이 조회
select distinct job from emp;

-- Ex2
--조회할 테이블은 EMP 테이블이며 모든 열을 출력하시오.
--별칭 (AS)
--EMPNO → EMPLOYEE_NO,
--ENAME → EMPLOYEE_NAME,
--MGR → MANAGER,
--SAL → SALARY,
--COMM → COMMISSION,
--DEPTNO → DEPARTMENT_NO

--부서번호를 기준으로 내림차순으로 정렬하되,
--부서번호가 같다면 사원이름을 기준으로 오름차순 정렬하시오.

select  EMPNO AS  EMPLOYEE_NO 
      , ENAME AS  EMPLOYEE_NAME
      , JOB 
      , MGR    MANAGER
      , SAL    SALARY
      , COMM   COMMISSION
      , DEPTNO  DEPARTMENT_NO
from  emp
order by DEPTNO DESC , ENAME ASC;


-- Ex3  
-- Q3. EMP테이블에서 대소비교연산자(<= , >= ) and 를 이용하여 sal 열이 2000이상 3000이하인인 행을 조회
select * from emp  where sal >= 2000 and  sal<=3000;

-- Ex3  
-- Q4. EMP테이블에서 BETWEEN AND 를 이용하여 sal 열이 2000이상 3000이하인인 행을 조회
select * from emp  where sal between 2000 and 3000;

-- Ex4
 EMP테이블에서 OR 를 이용하여 
-- JOB 열이 'MANAGER' ,'SALESMAN' , 'CLERK' 중 하나라도 포함되는 행을 조회
select * from emp  where job='MANAGER' or job='SALESMAN' or job= 'CLERK';

-- Ex5
EMP테이블에서 IN 를 이용하여 
-- JOB 열이 'MANAGER' ,'SALESMAN' , 'CLERK' 중 하나라도 포함되는 행을 조회
-- from → where  → select 
select * from emp  where job in ('MANAGER' ,'SALESMAN' , 'CLERK');


-- Ex6. EMP테이블에서 ENAME이 S로 시작하는 행
select * from emp  where ename like 'S%';


-- Ex7. EMP테이블에서 ENAME의 두번째 글자가 L인 행을 조회
select * from emp  where ename like '_L%';


-- Ex8. EMP테이블에서 ENAME에 AN이 포함되어 있는 행을 조회
select * from emp  where ename like '%AN%';

```