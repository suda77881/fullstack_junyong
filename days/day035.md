```java
package com.company.java016_javaio;

import java.io.File;

public class JavaIO001_folder_file {

	public static void main(String[] args) {
			// 1. 경로체크
			String folder_abs="C:\\file\\";	//절대경로(시스템의 폴더기준-전체경로 C:\)
			String folder_rel="src/com/company/java016_javaio_ex/";	//상대경로(현재작업 폴더기준) 슬러쉬 위치 주의
			String file_path="io001.txt";
			
			// 2. 폴더 + 파일 준비
			File folder = new File(folder_rel);	// ctrl + shift + o
			File file 	= new File(folder_rel + file_path);
			// 폴더가 없다면 		   폴더    만들기
			try {
			if (!folder.exists()) {folder.mkdir();}
			if (!file.exists()) {file.createNewFile();}
			
			}catch (Exception e) {e.printStackTrace();}
			System.out.println("폴더/파일 준비완료");
	}	// ctrl + f11 / f5 (새로고침)

}
```
 

 ```java
 package com.company.java016_javaio;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

/**
 * 
 */
public class JavaIO002_byte {

	/**
	 * @param args
	 */
	public static void main(String[] args) {
		//#1. 경로
		String folder_rel="src/com/company/java016_javaio_ex/";	//상대경로(현재작업 폴더기준) 슬러쉬 위치 주의
		String file_path="io002.txt";
		
		File folder = new File(folder_rel);
		File   file = new File(folder_rel + file_path);
		
		//#2. 폴더 + 파일만들기 
		try {
		if (!folder.exists()) { folder.mkdir();}
		if (  !file.exists()) { file.createNewFile();}
		}catch(Exception e) {e.printStackTrace();}
		
		//#3. byte 파일쓰기 	InputStream > [프로그램] > (OutputStream #)
		try {
			OutputStream output = new FileOutputStream(file);
			output.write('j');
			output.write('a');
			output.write('v');
			output.write('a');
			output.close();
			System.out.println("OutputStream 쓰기완료!");
		} catch (FileNotFoundException e) {e.printStackTrace();	// 파일을 못찾을경우
		} catch (IOException e) {e.printStackTrace();}	// 입력출력이 안될경우
		
		
		//#4. byte 파일읽기    (InputStream #) > [프로그램] > OutputStream #
		try {
			InputStream input = new FileInputStream(file);
			int cnt = 0;
			while( ( cnt=input.read() ) != -1) { // -1 끝
				System.out.print( (char) cnt );
			}
			input.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		
		
		
	}

}

/*
1. Java IO
- 입력(input)과 출력(output)
- 두 대상간의 데이터를 주고 받는것
- 스트림이란? 사용연결통로  

	입력스트림		→		[프로그램]		 →		 출력스트림				/ / 프로그램기준 단일
			InputStream 		OutputStream			
			Reader				Writer
2. Java IO 분류	  
- byte / char 단위
- byte 단위(InputStream / OutputStream) - 모든 종류( 그림, 멀티미디어, 문자 )
- char 단위(Reader	   / Writer)	  - 문자

3. 보조스트림
---------------------------------------------------------------------
- new BufferedReader(new InputStreamReader (FileInputStream(file)))	 바이트단위로 잘라서 받겠다
---------------------------------------------------------------------
- 1) new FileInputStream (네트워크나, 사용자가 넣어준 값) byte[#] / char
- 2) new InputStreamReader 바이트를 [문자]스트림으로 - 텍스트처리가능
- 3) new BufferedReader 속도향상
*/
```

```java
package com.company.java016_javaio;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.Reader;
import java.io.Writer;

public class JavaIO003_char {
	public static void main(String[] args) {
		//#1. 경로
		String folder_rel="src/com/company/java016_javaio_ex/";	//상대경로(현재작업 폴더기준) 슬러쉬 위치 주의
		String file_path="io003.txt";
		
		File folder = new File(folder_rel);
		File file   = new File(folder_rel+ file_path);
		
		
		//#2. 폴더 + 파일만들기	exists / mkdir / createNewFile
		try {
			if (!folder.exists()) {folder.mkdir();}
			if (!file.exists()) {file.createNewFile();}
			System.out.println("1) 파일/폴더 만들기");	
		}
		catch (Exception e) {e.printStackTrace();}
		
		
		
		//#3. char 쓰기	Reader > [프로그램] > (Writer #)
		try {
			Writer writer = new FileWriter(file);
			writer.write("hello\n");	// 버퍼에 저장
			writer.write("java ");	// 버퍼에 저장
			writer.flush();	// 버퍼 (임시저장공간)에 저장된 데이터를 강제로 출력스트림으로 밀어내기
							// 버퍼에 있는 내용을 즉시 파일에 쓰기
			writer.close();	// 스트림 닫기 (입력대기 상태를 해제)
			System.out.println("2) Writer 쓰기완료");
		} catch (IOException e) {	e.printStackTrace();	}
		
		//#4. char 읽기 	(Reader #) > [프로그램] > Writer
		
		try {
			Reader reader = new FileReader(file);
			int cnt=0;
			while( (cnt=reader.read()) != -1	) {
				System.out.print( (char)cnt );
			}
			reader.close();
		} catch (FileNotFoundException e) {  e.printStackTrace(); } 
		  catch (IOException e) {  e.printStackTrace();}
		

	}

}
 
```



```java

package com.company.java016_javaio;


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;

public class Network003_naver_news {

	public static void main(String[] args) {
		try {
			//#1. URL
			String apiurl = "https://openapi.naver.com/v1/search/news.json?query="	
				// String 자료형으로 apiurl 변수에 네이버 api 에서 지정한 book.json주소와, query="형식으로 검색할 수있게 만든다.
					+ URLEncoder.encode("캄보디아" , "UTF-8"); 
			// URLEncoder클래스의 encode메서드를 활용하여 , 삼총사라는 한글단어를 UTF-8형식으로 한글이 깨지지않게 인코딩하여 입력한다.
			
			// 검색창 예시 apple 검색어 : 
			// https://search.naver.com/search.naver?where=nexearch&sm=top_hty&fbm=0&ie=utf8& query=apple &ackey=ryau7ks8
			
			URL url = new URL(apiurl);
			
			//#2. HttpURLConnection
			HttpURLConnection conn = (HttpURLConnection)url.openConnection();
			// HttpURLConnection 클래스를 conn 변수에 담아서 (HttpURLConnection)자료형으로 url.openConnection(); 클래스.메서드를 담는다?
			//#3. 요청설정	- GET
			//	X-Naver-Client-Id: {애플리케이션 등록 시 발급받은 클라이언트 아이디 값}
			//	X-Naver-Client-Secret: {애플리케이션 등록 시 발급받은 클라이언트 시크릿 값}
			conn.setRequestMethod("GET");	// conn의 요청메서드를 GET으로 설정한다.
			conn.setRequestProperty("X-Naver-Client-Id", "5LXF8r4usyC9wB1R7H4m"); //conn의 요청속성을 ID = 발급받은아이디
			conn.setRequestProperty("X-Naver-Client-Secret", "kB5j9VUHrv");		  //conn의 요청속성을 Secret = 발급받은시크릣 으로 변경
			
			//#4. 응답확인
			BufferedReader br;	// Buffered 클래스로 br변수를 선언하고
			
			if(conn.getResponseCode() == 200) {	// 반환되는 코드가 200일시에
				br = new BufferedReader(new InputStreamReader(conn.getInputStream())); // 겟인풋스트림으로 정보를 받는다.
			}else {
				br = new BufferedReader(new InputStreamReader(conn.getErrorStream()));	// 에러인경우
				
			}
			//#5. 응답데이터
			String line="";	// 라인변수
			StringBuffer sb = new StringBuffer();
			while( (line = br.readLine()) != null) {sb.append(line + "\n");} 
			// 마지막줄이 아닌경우 (마지막줄 = null값)	sb.append로 줄단위+ 줄바꿈으로 담는다.
			
			
			System.out.println(sb.toString());
			br.close(); conn.disconnect();	//	버퍼를 닫고, 연결해제
			
		} catch (MalformedURLException e) { e.printStackTrace();	// 주소가 잘못 입력된 경우
		} catch (UnsupportedEncodingException e) { e.printStackTrace();
		} catch (IOException e) {  e.printStackTrace();
		}
		
	
	
	}// end main

}// end class




	/*
	 1. id / secret

	Client ID		5LXF8r4usyC9wB1R7H4m
	Client Secret	kB5j9VUHrv

	2. 요청 URL 

	https://openapi.naver.com/v1/search/news.xml	XML
	https://openapi.naver.com/v1/search/news.json	JSON

	3. HTTP 메서드 : GET 

	4. 파라미터 - 요청 내용을 주소 표시창줄에 데이터 넣어서 줄께 - 파라미터를 쿼리 스트링 형식으로 전달합니다.

	파라미터	타입	필수 여부	설명
	query	String	Y	검색어. UTF-8로 인코딩되어야 합니다.

	https://openapi.naver.com/v1/search/book.xml?query =사용자가 요청한값 (쿼리 스트링 형식)
	https://openapi.naver.com/v1/search/book.json?query=사용자가 요청한값 (쿼리 스트링 형식) 
	  
	*/



```


```java

package com.company.java016_javaio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;

public class Newtwork001_url {

	public static void main(String[] args) {
			
		try {
			//1. Url
			URL url = new URL("https://www.google.com/");
			
			//2. 연결객체 (HttpURLConnection)
			HttpURLConnection conn = (HttpURLConnection) url.openConnection();	
			
			//3. 요청설정
			conn.setRequestMethod("GET");	//	
			conn.setDoInput(true); conn.setDoOutput(true); conn.setReadTimeout(1000); // 1초
			//4. 응답코드
			int code = conn.getResponseCode(); // 구글에서 응답
			System.out.println(code);  		// 200 응답성공!	404페이지 없음 		500 코드오류
			//5. 응답데이터		BufferdReader	    >  [Network001 - 프로그램] > 			BufferedWriter 
			BufferedReader br;
			if(code == 200) { 
					// 한줄씩읽을 수 있게 속도향상	-바이트스트림을 문자스트림		  - 응답 데이터 스트림
				br = new BufferedReader(new InputStreamReader(		conn.getInputStream()));
			}else {
					//												  - 에러인 경우
				br = new BufferedReader(new InputStreamReader( 		conn.getErrorStream()));
			}
			String line=""; StringBuffer sb = new StringBuffer();
			while( ( line = br.readLine()) != null   ) { sb.append(line+"\n"); }	
			
			System.out.println(sb.toString());
			br.close(); conn.disconnect();
			
		} catch (MalformedURLException e) {  e.printStackTrace(); 
		} catch (IOException e) {  e.printStackTrace(); }
		
		

	}// end main

}// end class



/*
 1. id / secret

Client ID		5LXF8r4usyC9wB1R7H4m
Client Secret	kB5j9VUHrv

2. 요청 URL 

https://openapi.naver.com/v1/search/book.xml	XML
https://openapi.naver.com/v1/search/book.json	JSON

3. HTTP 메서드 : GET 

4. 파라미터 - 요청 내용을 주소 표시창줄에 데이터 넣어서 줄께 - 파라미터를 쿼리 스트링 형식으로 전달합니다.

파라미터	타입	필수 여부	설명
query	String	Y	검색어. UTF-8로 인코딩되어야 합니다.

https://openapi.naver.com/v1/search/book.xml?query =사용자가 요청한값 (쿼리 스트링 형식)
https://openapi.naver.com/v1/search/book.json?query=사용자가 요청한값 (쿼리 스트링 형식) 
  
*/


```


```java

package com.company.java016_javaio;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLEncoder;

public class Network002_naver_book {

	public static void main(String[] args) {
		try {
			//#1. URL
			String apiurl = "https://openapi.naver.com/v1/search/book.json?query="	
				// String 자료형으로 apiurl 변수에 네이버 api 에서 지정한 book.json주소와, query="형식으로 검색할 수있게 만든다.
					+ URLEncoder.encode("삼총사" , "UTF-8"); 
			// URLEncoder클래스의 encode메서드를 활용하여 , 삼총사라는 한글단어를 UTF-8형식으로 한글이 깨지지않게 인코딩하여 입력한다.
			
			// 검색창 예시 apple 검색어 : 
			// https://search.naver.com/search.naver?where=nexearch&sm=top_hty&fbm=0&ie=utf8& query=apple &ackey=ryau7ks8
			
			URL url = new URL(apiurl);
			
			//#2. HttpURLConnection
			HttpURLConnection conn = (HttpURLConnection)url.openConnection();
			// HttpURLConnection 클래스를 conn 변수에 담아서 (HttpURLConnection)자료형으로 url.openConnection(); 클래스.메서드를 담는다?
			//#3. 요청설정	- GET
			//	X-Naver-Client-Id: {애플리케이션 등록 시 발급받은 클라이언트 아이디 값}
			//	X-Naver-Client-Secret: {애플리케이션 등록 시 발급받은 클라이언트 시크릿 값}
			conn.setRequestMethod("GET");	// conn의 요청메서드를 GET으로 설정한다.
			conn.setRequestProperty("X-Naver-Client-Id", "5LXF8r4usyC9wB1R7H4m"); //conn의 요청속성을 ID = 발급받은아이디
			conn.setRequestProperty("X-Naver-Client-Secret", "kB5j9VUHrv");		  //conn의 요청속성을 Secret = 발급받은시크릣 으로 변경
			
			//#4. 응답확인
			BufferedReader br;	// Buffered 클래스로 br변수를 선언하고
			
			if(conn.getResponseCode() == 200) {	// 반환되는 코드가 200일시에
				br = new BufferedReader(new InputStreamReader(conn.getInputStream())); // 겟인풋스트림으로 정보를 받는다.
			}else {
				br = new BufferedReader(new InputStreamReader(conn.getErrorStream()));	// 에러인경우
				
			}
			//#5. 응답데이터
			String line="";	// 라인변수
			StringBuffer sb = new StringBuffer();
			while( (line = br.readLine()) != null) {sb.append(line + "\n");} 
			// 마지막줄이 아닌경우 (마지막줄 = null값)	sb.append로 줄단위+ 줄바꿈으로 담는다.
			
			
			System.out.println(sb.toString());
			br.close(); conn.disconnect();	//	버퍼를 닫고, 연결해제
			
		} catch (MalformedURLException e) { e.printStackTrace();	// 주소가 잘못 입력된 경우
		} catch (UnsupportedEncodingException e) { e.printStackTrace();
		} catch (IOException e) {  e.printStackTrace();
		}
		
	
	
	}// end main

}// end class



	/*
	 1. id / secret

	Client ID		5LXF8r4usyC9wB1R7H4m
	Client Secret	kB5j9VUHrv

	2. 요청 URL 

	https://openapi.naver.com/v1/search/book.xml	XML
	https://openapi.naver.com/v1/search/book.json	JSON

	3. HTTP 메서드 : GET 

	4. 파라미터 - 요청 내용을 주소 표시창줄에 데이터 넣어서 줄께 - 파라미터를 쿼리 스트링 형식으로 전달합니다.

	파라미터	타입	필수 여부	설명
	query	String	Y	검색어. UTF-8로 인코딩되어야 합니다.

	https://openapi.naver.com/v1/search/book.xml?query =사용자가 요청한값 (쿼리 스트링 형식)
	https://openapi.naver.com/v1/search/book.json?query=사용자가 요청한값 (쿼리 스트링 형식) 
	  
	*/


```



```java

package com.company.java016_javaio;

public class JavaIO006_StringBuffer {
	public static void main(String[] args) {
		//#1. 		String 문자열누적 - 새로운 주소 (변형 X)
		String str = "ABC";		// 1번지 = 1번지 ["ABC"] heap
		System.out.println("1. str주소 > " + str + " " + System.identityHashCode(str));
		
		str += "D";				// 2번지 = 2번지 ["ABCD"] heap
		System.out.println("2. str주소 > " + str + " " + System.identityHashCode(str));
		
		//#2. StringBuffer 문자열누적 - 기존 주소 (변형 O)
		StringBuffer sb = new StringBuffer();
		sb.append("ABC");
		System.out.println("3. str주소 > " + sb + " " + System.identityHashCode(sb));
		
		sb.append("D");
		System.out.println("4. str주소 > " + sb + " " + System.identityHashCode(sb));
		
		
		
	}

}



```


```java

package com.company.java016_javaio;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.Calendar;

public class JavaIO005_buffered {

	public static void main(String[] args) throws IOException {
		//#1. 경로
		Calendar today = Calendar.getInstance();	// 날짜
		String folder_rel="src/com/company/java016_javaio_ex/";	//상대경로(현재작업 폴더기준) 슬러쉬 위치 주의
		String file_path= 
			"io005_" + today.get(1) + (today.get(2)+1) + today.get(5) + ".txt";
		// 					 년				 월 				     일		
		File folder = new File(folder_rel);
		File   file = new File(folder_rel + file_path);
		
		//#2. 폴더 + 파일 만들기 [##]
		
		if (!(folder.exists())) {folder.mkdir();};
		if (!(	file.exists())) {file.createNewFile();};
		System.out.println("> 1. 폴더 + 파일준비완료");

		
		//#3. 파일쓰기	 InputStream >	[프로그램] > OutputStream #
		// BufferedWriter(속도향상) - OutputStreamWriter(단어) - FileOutputStream(byte)
		// a(버퍼) → a(비우기) abc(버퍼) → abc(한번에 모았다가 비우기)
		BufferedWriter bw =
		new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));
		
		bw.write("1, white, 1200\n");
		bw.write("2, choco, 1500\n");
		bw.write("3, banana, 1800\n");
		bw.close();
		System.out.println("> 2. 쓰기완료");
		
		//#4. 파일읽기  InputStream # >	[프로그램] > OutputStream
		// BufferedReader(속도향상) - InputStreamReader(단어) - FileInputStream(byte)
		
		BufferedReader br = 
				new BufferedReader(new InputStreamReader(new FileInputStream(file)));
		
		String line=""; // 수정되지않는
		StringBuffer sb = new StringBuffer(); // 수정가능한
		
		while ( (line = br.readLine()) != null ) { sb.append(line + "\n"); }
		System.out.println( sb.toString() );
		
		br.close();
	}

}

/*
1. Java IO
- 입력(input)과 출력(output)
- 두 대상간의 데이터를 주고 받는것
- 스트림이란? 사용연결통로  

	입력스트림		→		[프로그램]		 →		 출력스트림				/ / 프로그램기준 단일
			InputStream 		OutputStream			
			Reader				Writer
2. Java IO 분류	  
- byte / char 단위
- byte 단위(InputStream / OutputStream) - 모든 종류( 그림, 멀티미디어, 문자 )
- char 단위(Reader	   / Writer)	  - 문자

3. 보조스트림
---------------------------------------------------------------------
- new BufferedReader(new InputStreamReader (FileInputStream(file)))	 바이트단위로 잘라서 받겠다
---------------------------------------------------------------------
- 1) new FileInputStream (네트워크나, 사용자가 넣어준 값) byte[#] / char
- 2) new InputStreamReader 바이트를 [문자]스트림으로 - 텍스트처리가능
- 3) new BufferedReader 속도향상

*/

```

```
1. id / secret

Client ID		
Client Secret	

2. 요청 URL 

https://openapi.naver.com/v1/search/book.xml	XML
https://openapi.naver.com/v1/search/book.json	JSON

3. HTTP 메서드 : GET 

4. 파라미터 - 요청 내용을 주소 표시창줄에 데이터 넣어서 줄께 - 파라미터를 쿼리 스트링 형식으로 전달합니다.

파라미터	타입	필수 여부	설명
query	String	Y	검색어. UTF-8로 인코딩되어야 합니다.

https://openapi.naver.com/v1/search/book.xml?query =사용자가 요청한값 (쿼리 스트링 형식)
https://openapi.naver.com/v1/search/book.json?query=사용자가 요청한값 (쿼리 스트링 형식)

```

1. java
# ■ file
# ■ network

2. -----------------
# ■ Github - revert / reset
1. revert - 안전한 취소        - 깃허브 [공용]
2. reset  - 아예 지워버리기     - [혼자] 브랜치에서  


실습(1) revert
1. 본인 브랜치에서 파일작성 - test브랜치에서 새작업하고 원격저장소에 푸시
```bash

git branch
git checkout 테스트브랜치명
파일작성 revert_test.md

git add .
git commit -m "revert"
git push origin 테스트브랜치명

```
2. master 브랜치에서 병합 - test브랜치작업을 master에서 병합하고 푸시
```bash

git checkout master
git pull origin master
git merge   테스트브랜치명
git push origin master
```
3. master 브랜치에서 되돌리기
```bash
git checkout master
git log 
git revert <commit_hash>
git push origin master
```


Q1. 팀장 - test3.md revert vs reset
    main - commit 1 - merge
    main - commit 2 - merge
    main - commit 3 - merge     -merge 3번
Q2. 팀원 - .md 본인소개 / commit / main에서 merge - revert 해서 본인이 남긴거 지우기





순서요약

git checkout -b test
test 브랜치 생성(생성+ 자동이동 (현재 확인 : git branch))
test 브랜치에서 파일 작성 또는 수정후 git add 파일명 → git commit -m "메세지" → git push origin test 까지
이후 master 브랜치로 변경
git merge test → 병합 시작, 충돌 해결 후 저장 → git add 파일명 → git commit -m "메세지" → git push origin master
git log 로 해시코드 조회
git revert 해시코드 로 revert 작업후 (이때 커밋메세지가 동일하거나 병합 커밋일 경우 -m 옵션이 필요해짐)
git add 파일명 → git commit -m "메세지" → git push origin master


git log시 위로 올라갈수록 최근 커밋순 이고,

git revert는 커밋을 되돌리는 새 커밋 생성

git revert -m 숫자가 필요한 경우는 이번 실습에서

1인 경우 master (현재 branch)
2인 서브 test   (병합 branch)

'git revert -m 1' 해시코드 로 되돌리는 경우는 test 브랜치의 변경 사항을 master에서 제거하는 효과



Q 근데 실습할때 git revert -m 1 해시코드 로 한 이유가뭘까?


🔍 왜 -m 1이 필요한가?
머지 커밋은 두 개 이상의 부모 커밋을 갖는 특수한 커밋입니다.
예를 들어:
Merge: A B


- A: 첫 번째 부모 (보통 현재 브랜치, 예: master)
- B: 두 번째 부모 (병합된 브랜치, 예: test)
git revert는 일반 커밋을 되돌릴 때는 문제가 없지만, 머지 커밋을 되돌릴 때는 어떤 부모를 기준으로 되돌릴지 명확히 지정해야 합니다. 그렇지 않으면 Git이 혼란스러워하고 revert를 거부하거나 충돌을 일으켜요.

✅ -m 1의 의미
- -m 1은 **첫 번째 부모(A)**를 기준으로 되돌리겠다는 뜻
- 즉, 병합된 브랜치(test)의 변경 사항을 제거하고, master 브랜치의 원래 상태로 되돌리는 것

💡 예시
git revert -m 1 daf25a33


- daf25a33은 머지 커밋
- -m 1은 master 브랜치를 기준으로 병합을 되돌림
- 결과: test 브랜치의 변경 사항이 제거됨

⚠️ 실수 방지 팁
- git log로 머지 커밋인지 확인 (Merge: 표시 있음)
- git show <해시>로 부모 커밋 확인 가능
- -m 1 또는 -m 2를 잘못 지정하면 원하지 않는 방향으로 되돌려질 수 있음

정리하자면, git revert -m 1은 머지 커밋을 되돌릴 때 반드시 필요한 옵션이고,
어떤 브랜치의 변경 사항을 제거할지 명확히 지정하는 역할을 합니다.
원하시면 -m 2를 썼을 때 어떤 일이 벌어지는지도 예시로 보여드릴게요 😄


3. -----------------
# ■ oracle - select
# ■ group 

4. -------------------
자격증 및 정리


Q-1-1. C Class의 네트워크 주소가 192.169.10.0
Q-2-2. 서브넷 마스크가 '255.255.255.240' , 최대 사용가능한 호스트수 ? 14개


풀이 0) A (0) / B (128) / C (192) / D (240)
풀이 1) 8*4=32bit
	   11111111 / 11111111 / 11111111 /   표현방법
	   0~255(256)  0~255(256) 0~255(256)  0~240(256)
	   									  256-240 = 16개 - 2 (네트워크 ID + 브로드캐스트 ID)
										  = 14개

* ip 단위 : 256 - 240 (마지막)
* cidr							서브넷마스크	    ip단위로 나뉘는 크기
	/25 (1이 앞에서 25개)		255.255.255.128		128개
	/26 (1이 앞에서 25개) 		255.255.255.192		64개
	/27 (1이 앞에서 25개) 		255.255.255.224		32개

```

순서요약

git checkout -b test
test 브랜치 생성(생성+ 자동이동 (현재 확인 : git branch))
test 브랜치에서 파일 작성 또는 수정후 git add 파일명 → git commit -m "메세지" → git push origin test 까지
이후 master 브랜치로 변경
git merge test → 병합 시작, 충돌 해결 후 저장 → git add 파일명 → git commit -m "메세지" → git push origin master
git log 로 해시코드 조회
git revert 해시코드 로 revert 작업후 (이때 커밋메세지가 동일하거나 병합 커밋일 경우 -m 옵션이 필요해짐)
git add 파일명 → git commit -m "메세지" → git push origin master


git log시 위로 올라갈수록 최근 커밋순 이고,

git revert는 커밋을 되돌리는 새 커밋 생성

git revert -m 숫자가 필요한 경우는 이번 실습에서

1인 경우 master (현재 branch)
2인 서브 test   (병합 branch)

'git revert -m 1' 해시코드 로 되돌리는 경우는 test 브랜치의 변경 사항을 master에서 제거하는 효과


```



